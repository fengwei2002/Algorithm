[周赛链接](https://leetcode-cn.com/contest/weekly-contest-279/)

- [T1题解](https://leetcode-cn.com/problems/sort-even-and-odd-indices-independently/solution/lc2164-t1-fengwei2002-by-konng0120-ksmd/)
- [T2题解](https://leetcode-cn.com/problems/smallest-value-of-the-rearranged-number/solution/lc2165-t2-fengwei2002-by-konng0120-i9a4/)
- [T3题解](https://leetcode-cn.com/problems/design-bitset/solution/lc2166-t3-fengwei2002-by-konng0120-pqfu/)
- [T4题解](https://leetcode-cn.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/solution/lc2167-t4-fengwei2002-by-konng0120-izoq/)

### [2164\. 对奇偶下标分别排序](https://leetcode-cn.com/problems/sort-even-and-odd-indices-independently/)



给你一个下标从 **0** 开始的整数数组 `nums` 。根据下述规则重排 `nums` 中的值：

1.  按 **非递增** 顺序排列 `nums` **奇数下标** 上的所有值。
    *   举个例子，如果排序前 `nums = [4,_**1**_,2,_**3**_]` ，对奇数下标的值排序后变为 `[4,_**3**_,2,_**1**_]` 。奇数下标 `1` 和 `3` 的值按照非递增顺序重排。
2.  按 **非递减** 顺序排列 `nums` **偶数下标** 上的所有值。
    *   举个例子，如果排序前 `nums = [_**4**_,1,_**2**_,3]` ，对偶数下标的值排序后变为 `[_**2**_,1,_**4**_,3]` 。偶数下标 `0` 和 `2` 的值按照非递减顺序重排。

返回重排 `nums` 的值之后形成的数组。

**示例 1：**

```
输入：nums = [4,1,2,3]
输出：[2,3,4,1]
解释：
首先，按非递增顺序重排奇数下标（1 和 3）的值。
所以，nums 从 [4,1,2,3] 变为 [4,3,2,1] 。
然后，按非递减顺序重排偶数下标（0 和 2）的值。
所以，nums 从 [4,1,2,3] 变为 [2,3,4,1] 。
因此，重排之后形成的数组是 [2,3,4,1] 。
```

**示例 2：**

```
输入：nums = [2,1]
输出：[2,1]
解释：
由于只有一个奇数下标和一个偶数下标，所以不会发生重排。
形成的结果数组是 [2,1] ，和初始数组一样。 
```

**提示：**

*   `1 <= nums.length <= 100`
*   `1 <= nums[i] <= 100`

模拟即可

``` cpp 
class Solution {
public:
    vector<int> sortEvenOdd(vector<int>& nums) {
        // 从大到小排序计数
        // 从小到大排序偶数
        vector<int> a;
        vector<int> b;
        for (int i = 0; i < nums.size(); i++) {
            if ((i) % 2 == 1) {
                a.push_back(nums[i]);
            } else {
                b.push_back(nums[i]);
            }
        }
        sort(a.begin(), a.end(), [&](int a, int b) {
            return a > b;
        });
        sort(b.begin(), b.end());
        vector<int> ans(0, 0);
        int indexa = 0, indexb = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (i % 2 == 1) {
                ans.push_back(a[indexa]);
                indexa++;
            } else {
                ans.push_back(b[indexb]);
                indexb++;
            }
        }
        return ans;
    }
};
```

### [2165\. 重排数字的最小值](https://leetcode-cn.com/problems/smallest-value-of-the-rearranged-number/)

给你一个整数 `num` 。**重排** `num` 中的各位数字，使其值 **最小化** 且不含 **任何** 前导零。

返回不含前导零且值最小的重排数字。

注意，重排各位数字后，`num` 的符号不会改变。

**示例 1：**

```
输入：num = 310
输出：103
解释：310 中各位数字的可行排列有：013、031、103、130、301、310 。
不含任何前导零且值最小的重排数字是 103 。
```

**示例 2：**

```
输入：num = -7605
输出：-7650
解释：-7605 中各位数字的部分可行排列为：-7650、-6705、-5076、-0567。
不含任何前导零且值最小的重排数字是 -7650 。
```

**提示：**

*   `-10<sup>15</sup> <= num <= 10<sup>15</sup>`

---

把数字转换为数组，
- 如果是正数，sort 数组，然后把第一个不为 0 的值放在起点，生成数字即可行
- 如果是负数，从大到小 sort 数组，然后生成数字，注意乘上 minus 

``` cpp 
class Solution {
public:
    typedef long long LL;
    long long smallestNumber(long long num) {
        LL sign = 1;
        if (num < 0) sign = -1;
        vector<LL> a(0, 0);
        while (num > 0) {
            a.push_back(num % 10);
            num /= 10;
        }
        if (sign == 1) {
            sort(a.begin(), a.end());

            // 找出前导零的下标
            LL index = -1;
            for (LL i = 0; i < a.size(); i++) {
                if (a[i] == 0) {
                    index = i;
                } else {
                    break;
                }
            }
            if (index == a.size() - 1) {
                return 0;
            }

            if (index != -1) {
                swap(a[index + 1], a[0]);
            }
            long long ans = 0;
            for (LL i = 0; i < a.size(); i++) {
                ans *= 10;
                ans += a[i];
            }
            return ans;
        } else {
            LL ans = 0;
            a.clear();
            num = -num;
            while (num > 0) {
                a.push_back(num % 10);
                num /= 10;
            }
            sort(a.begin(), a.end(), [&](LL a, LL b) {
                return a > b;
            });
            
            for (LL i = 0 ;i < a.size(); i++) {
                ans *= 10;
                ans += a[i];
            }
            ans *= sign;
            return ans;
        }
        return -1;
    }
};
```

### [2166\. 设计位集](https://leetcode-cn.com/problems/design-bitset/)


**位集 Bitset** 是一种能以紧凑形式存储位的数据结构。

请你实现 `Bitset` 类。

*   `Bitset(int size)` 用 `size` 个位初始化 Bitset ，所有位都是 `0` 。
*   `void fix(int idx)` 将下标为 `idx` 的位上的值更新为 `1` 。如果值已经是 `1` ，则不会发生任何改变。
*   `void unfix(int idx)` 将下标为 `idx` 的位上的值更新为 `0` 。如果值已经是 `0` ，则不会发生任何改变。
*   `void flip()` 翻转 Bitset 中每一位上的值。换句话说，所有值为 `0` 的位将会变成 `1` ，反之亦然。
*   `boolean all()` 检查 Bitset 中 **每一位** 的值是否都是 `1` 。如果满足此条件，返回 `true` ；否则，返回 `false` 。
*   `boolean one()` 检查 Bitset 中 是否 **至少一位** 的值是 `1` 。如果满足此条件，返回 `true` ；否则，返回 `false` 。
*   `int count()` 返回 Bitset 中值为 1 的位的 **总数** 。
*   `String toString()` 返回 Bitset 的当前组成情况。注意，在结果字符串中，第 `i` 个下标处的字符应该与 Bitset 中的第 `i` 位一致。

**示例：**

```
输入
["Bitset", "fix", "fix", "flip", "all", "unfix", "flip", "one", "unfix", "count", "toString"]
[[5], [3], [1], [], [], [0], [], [], [0], [], []]
输出
[null, null, null, null, false, null, null, true, null, 2, "01010"]

解释
Bitset bs = new Bitset(5); // bitset = "00000".
bs.fix(3);     // 将 idx = 3 处的值更新为 1 ，此时 bitset = "00010" 。
bs.fix(1);     // 将 idx = 1 处的值更新为 1 ，此时 bitset = "01010" 。
bs.flip();     // 翻转每一位上的值，此时 bitset = "10101" 。
bs.all();      // 返回 False ，bitset 中的值不全为 1 。
bs.unfix(0);   // 将 idx = 0 处的值更新为 0 ，此时 bitset = "00101" 。
bs.flip();     // 翻转每一位上的值，此时 bitset = "11010" 。
bs.one();      // 返回 True ，至少存在一位的值为 1 。
bs.unfix(0);   // 将 idx = 0 处的值更新为 0 ，此时 bitset = "01010" 。
bs.count();    // 返回 2 ，当前有 2 位的值为 1 。
bs.toString(); // 返回 "01010" ，即 bitset 的当前组成情况。
```

**提示：**

*   `1 <= size <= 10<sup>5</sup>`
*   `0 <= idx <= size - 1`
*   至多调用 `fix`、`unfix`、`flip`、`all`、`one`、`count` 和 `toString` 方法 **总共** 10<sup>5</sup> 次
*   至少调用 `all`、`one`、`count` 或 `toString` 方法一次
*   至多调用 `toString` 方法 `5` 次

---

实现 bitset 类，如果不做任何优化就是这样：

``` cpp
class Bitset {
public:
    vector<int> bb;
    Bitset(int size) {
        bb.resize(size);
        for (int i = 0; i < size; i++) {
            bb[i] = 0;
        }
    }
    
    void fix(int idx) {
        if (bb[idx] == 1) {
            // do nothing;
        } else {
            bb[idx] = 1;
        }
    }
    
    void unfix(int idx) {
        if (bb[idx] == 0) {
            // do nothing;
        } else {
            bb[idx] = 0;
        }
    }
    
    void flip() {
        for (int i = 0; i < bb.size(); i++) {
            if (bb[i] == 0) {
                bb[i] = 1;
            } else {
                bb[i] = 0;
            }
        }
    }
    
    bool all() {
        bool ans = false;
        int index = 0;
        for (int i = 0; i < bb.size(); i++) {
            if (bb[i] == 1) {
                index++;
            } else {
                break;
            }
        }
        if (index == bb.size()) {
            ans = true;
        }
        return ans;
    }
    
    bool one() {
        bool ans = false;
        
        for (int i = 0; i < bb.size(); i++) {
            if (bb[i] == 1) {
                ans = true;
                break;
            }
        }
        return ans;
    }
    
    int count() {
        int sum = 0;
        for (int i = 0; i < bb.size(); i++) {
            if (bb[i] == 1) {
                sum++;
            }
        }
        return sum;
    }
    
    string toString() {
        string ans = "";
        for (int i = 0; i < bb.size(); i++) {
            ans += to_string(bb[i]);
        }
        return ans;
    }
};

/**
 * Your Bitset object will be instantiated and called as such:
 * Bitset* obj = new Bitset(size);
 * obj->fix(idx);
 * obj->unfix(idx);
 * obj->flip();
 * bool param_4 = obj->all();
 * bool param_5 = obj->one();
 * int param_6 = obj->count();
 * string param_7 = obj->toString();
 */
```

会有 4 个很大的数据 TLE，然后题目数据量是 10 的 5 次方，所以需要 O 1 时间内完成除了 tostring 的所有方法:


``` cpp
class Bitset {
private:
    vector<int> arr;    // 存储每一位的数组
    int cnt = 0;        // 1 的个数
    int reversed = 0;   // 反转操作的次数奇偶性
public:
    Bitset(int size) {
        arr.resize(size);
        cnt = 0;
        reversed = 0;
    }
    
    void fix(int idx) {
        // 当 reversed 为 0 并且 arr[idx] 为 0 的时候需要置为 1
        // 当 reversed 为 1 并且 arr[idx] 为 1 的时候需要置为 1
        if ((arr[idx] ^ reversed) == 0) {
            arr[idx] ^= 1;
            ++cnt;
        }
    }
    
    void unfix(int idx) {
        // 当 reversed 为 0 并且 arr[idx] 为 1 的时候需要置为 0
        // 当 reversed 为 1 并且 arr[idx] 为 0 的时候需要置为 0
        if ((arr[idx] ^ reversed) == 1) {
            arr[idx] ^= 1;
            --cnt;
        }
    }
    
    void flip() {
        // 反转的话，总状态切换
        reversed ^= 1;
        // 一个个数取反
        cnt = arr.size() - cnt;
    }
    
    bool all() {
        // 判断一的个数是否和总个数相等
        return cnt == arr.size();
    }
    
    bool one() {
        // 判断一的个数是否大于 0
        return cnt > 0;
    }
    
    int count() {
        // 返回 1 的个数
        return cnt;
    }
    
    string toString() {
        string ans;
        for (int bit: arr) {
            ans.push_back('0' + (bit ^ reversed));
        }
        return ans;
    }
};
```

异或实现 bitset，学到了


### [2167\. 移除所有载有违禁货物车厢所需的最少时间](https://leetcode-cn.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/)


给你一个下标从 **0** 开始的二进制字符串 `s` ，表示一个列车车厢序列。`s[i] = '0'` 表示第 `i` 节车厢 **不** 含违禁货物，而 `s[i] = '1'` 表示第 `i` 节车厢含违禁货物。

作为列车长，你需要清理掉所有载有违禁货物的车厢。你可以不限次数执行下述三种操作中的任意一个：

1.  从列车 **左** 端移除一节车厢（即移除 `s[0]`），用去 1 单位时间。
2.  从列车 **右** 端移除一节车厢（即移除 `s[s.length - 1]`），用去 1 单位时间。
3.  从列车车厢序列的 **任意位置** 移除一节车厢，用去 2 单位时间。

返回移除所有载有违禁货物车厢所需要的 **最少** 单位时间数。

注意，空的列车车厢序列视为没有车厢含违禁货物。

**示例 1：**

``` cpp
输入：s = "1100101"
输出：5
解释：
一种从序列中移除所有载有违禁货物的车厢的方法是：
- 从左端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。
- 从右端移除一节车厢 1 次。所用时间是 1 。
- 移除序列中间位置载有违禁货物的车厢。所用时间是 2 。
总时间是 2 + 1 + 2 = 5 。

一种替代方法是：
- 从左端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。
- 从右端移除一节车厢 3 次。所用时间是 3 * 1 = 3 。
总时间也是 2 + 3 = 5 。

5 是移除所有载有违禁货物的车厢所需要的最少单位时间数。
没有其他方法能够用更少的时间移除这些车厢。
```

**示例 2：**

``` cpp
输入：s = "0010"
输出：2
解释：
一种从序列中移除所有载有违禁货物的车厢的方法是：
- 从左端移除一节车厢 3 次。所用时间是 3 * 1 = 3 。
总时间是 3.

另一种从序列中移除所有载有违禁货物的车厢的方法是：
- 移除序列中间位置载有违禁货物的车厢。所用时间是 2 。
总时间是 2.

另一种从序列中移除所有载有违禁货物的车厢的方法是：
- 从右端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。
总时间是 2.

2 是移除所有载有违禁货物的车厢所需要的最少单位时间数。
没有其他方法能够用更少的时间移除这些车厢。
```

**提示：**

*   `1 <= s.length <= 2 * 10<sup>5</sup>`
*   `s[i]` 为 `'0'` 或 `'1'`

---

对于字符串 s 中的每一个 1，记录他的下标为 i， 根据题目要求，要想把这个违禁车厢删除，就必须满足下面三个条件之一：
- 从左侧开始，将 0 到 i 范围内的车厢全部删除（包括第 i 个车厢），用去 i + 1 的时间
- 从中间进行删除，用去 2 个单位时间
- 从右侧开始，将 i 到 n 范围内的车厢全部移除，用去 n - i 单位时间，其中 n 是字符串 s 的长度

如果把 s 中每一个 1 满足的条件进行合并，最终的移除方法就是两种情况：
- 字符串中的所有字符都被删除， 用去 n 单位的时间
- 存在一个区间 i 到 j ，区间左侧的字符全部被删除， 区间右侧的字符全部被删除，区间内的 1 全部被删除, 用去 `i + (n - j + 1) + 2 * count1(i, j)` 单位时间

---

考虑左半部分的最少时间
- 定义 pre[i] 表示移除前 i 节车厢中的所有违禁货物车厢所花费的时间
    - 当 s[i] = 0 的时候，无需移除车厢，则有 pre[i] = pre[i - 1]
    - 当 s[i] = 1 的时候，可以单独移除第 i 节车厢，也可以移除前面共 i 个车厢，二者去最小值
      - `pre[i] = min(pre[i - 1] + 2, i + 1)`
对于右半部分，
- 同样定义 `suf[i]` 表示移除后面 i 节车厢中，所有违禁货物车厢所花费的最少的时间，有
  - 当 `s[i] = 0` 的时候，`suf[i] = suf[i + 1]`
  - 当 `s[i] = 1` 的时候，`suf[i] = min(suf[i + 1] + 2, n - i)` 

枚举每个位置的分割点，计算所有 `pre[i] + suf[i + 1]` 的最小值

``` cpp
class Solution {
public:
    int minimumTime(string s) {
        int n = s.size();
        vector<int> pre(n, 0);
        vector<int> suf(n, 0);
        for (int i = 0; i < n; i++) {
            if (i == 0) {
                if (s[0] == '0') {
                    pre[0] = 0;
                } else {
                    pre[0] = 1;
                }
                continue;
            }
            if (s[i] == '0') {
                pre[i] = pre[i - 1];
            } else {
                pre[i] = min(pre[i - 1] + 2, i + 1);
            }
        }
        for (int i = n - 1; i >= 0; i--) {
            if (i == n - 1) {
                if (s[n - 1] == '0') {
                    suf[n - 1] = 0;
                } else {
                    suf[n - 1] = 1;
                }
                continue;
            } 
            if (s[i] == '0') {
                suf[i] = suf[i + 1];
            } else {
                suf[i] = min(suf[i + 1] + 2, (n - 1) - i + 1);
            }
        }
        // pre[i] 表示 s[i] 在左边的情况
        // suf[i] 表示 s[i] 在右边的情况
        int ans = INT_MAX;
        if (n == 1) {
            ans = pre[0];
        } else {
            for (int i = 0; i < n - 1; i++) {
                ans = min(ans, pre[i] + suf[i + 1]);
            }
        }

        return ans;
    }
};
```