[题目链接](https://leetcode-cn.com/problems/pseudo-palindromic-paths-in-a-binary-tree/)  
[题解链接](https://leetcode-cn.com/problems/pseudo-palindromic-paths-in-a-binary-tree/solution/lc1457-fengwei2002-by-kycu-kwq5/)

https://github.com/fengwei2002/algorithm

### 1457. 二叉树中的伪回文路径

给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「伪回文」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。

请你返回从根到叶子节点的所有路径中 伪回文 路径的数目。

### 思路

看到题目不要怕，你要想那么多人都会写，所以这你应该也会写

对于这个问题，

他问的是，对于所有路径，找到路径中可以构成伪回文串的路径数量

- 先将所有的路径放入一个二维数组中  
- 然后遍历每一个路径，如果这个路径中的数字出现次数为奇数 的数字个数 <= 1 那么这个路径就是 伪回文串
- 遇到一个伪回文串结果加一， 返回结果即可

``` cpp
class Solution {
public:
    int pseudoPalindromicPaths (TreeNode* root) {
        // ---第一步：找到所有的二叉树路径， 将所有的二维路径存储在 paths 中
        int ans = 0;
        vector<vector<int>> paths;
        vector<int> path;
        dfs(root, path, paths);
        
        // ---第二步：在所有路径中寻找回文路径
        for (int i = 0; i < paths.size(); i++) {
            unordered_map<int, int> hash;
            // paths[i] == 路径
            int a = 0, b = 0;
            for (int j = 0; j < paths[i].size(); j++) {
                hash[paths[i][j]]++;
            }
            for (auto &[x, f] : hash) {
                if (f % 2 == 1) b++;
            } // 遍历所有哈希表，统计出现次数是 奇数 的个数
            if (b <= 1) {
                ans++;
            } // 如果 出现次数 是 奇数 的 个数，小于等于 1，ans++
        }        
        return ans;
    }

    void dfs(TreeNode* root, vector<int>& path, vector<vector<int>>& paths) {
        if (root != nullptr) {
            path.push_back(root->val); 
            if (root->left == nullptr && root->right == nullptr) {
                paths.push_back(path);
            } else {
                dfs(root->left, path, paths);
                dfs(root->right, path, paths);
            }
            path.pop_back();
        } else {
            return;
        }
    }
};
```

![20211023130501-2021-10-23-13-05-03](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/images/20211023130501-2021-10-23-13-05-03.png)


观察题目数据范围；

发现 **节点值在 1 到 9 之间**，也就是 hash 中只存储最多 9 个数字，所以可以用一个数组将哈希表替换，每个下标存储的值就是 对应数字 的出现次数


``` cpp 
class Solution {
public:
    int pseudoPalindromicPaths (TreeNode* root) {
        // ---第一步：找到所有的二叉树路径， 将所有的二维路径存储在 paths 中
        int ans = 0;
        vector<vector<int>> paths;
        vector<int> path;
        dfs(root, path, paths);
        
        // ---第二步：在所有路径中寻找回文路径
        for (int i = 0; i < paths.size(); i++) {
            int hash[10] = {0};
            // paths[i] == 路径
            int a = 0, b = 0;
            for (int j = 0; j < paths[i].size(); j++) {
                hash[paths[i][j]]++;
            }
            for (auto& i: hash) {
                if (i % 2 == 1) b++;
            } // 遍历所有哈希表，统计出现次数是 奇数 的个数
            if (b <= 1) {
                ans++;
            } // 如果 出现次数 是 奇数 的 个数，小于等于 1，ans++
        }        
        return ans;
    }

    void dfs(TreeNode* root, vector<int>& path, vector<vector<int>>& paths) {
        if (root != nullptr) {
            path.push_back(root->val); 
            if (root->left == nullptr && root->right == nullptr) {
                paths.push_back(path);
            } else {
                dfs(root->left, path, paths);
                dfs(root->right, path, paths);
            }
            path.pop_back();
        } else {
            return;
        }
    }
};
```

答案正确，但是仍然是 53/56 数据通过，所以是方法需要更新，而不是选用的数据结构㤇更新

考虑哪里还可以进行时间压缩，由于遍历路径的过程不可能优化，所以需要考虑优化 |统计 路径中 出现次数为奇数 的 个数| 这个过程

可以将这个过程融合到 求路径的搜索中，这样就不用再 $O(n^2)$ 的遍历 paths 了


``` cpp
class Solution {
   public:
    int ans = 0;

    void dfs(TreeNode* root, vector<int>& cnt) {
        if (root == nullptr) return;
        cnt[root->val]++;
        if (root->left == nullptr && root->right == nullptr) {
            // 说明到达了一条路径末尾节点。并没有必要将路径保存下来，遍历进行判断
            int even = 0;
            for (auto i : cnt) {
                if (i % 2 == 1) even++; 
            }
            if (even <= 1) ans++;
        }

        dfs(root->left, cnt);
        dfs(root->right, cnt);

        cnt[root->val]--; 
    }

    int pseudoPalindromicPaths(TreeNode* root) {
        vector<int> cnt(10, 0); // cnt 用来统计路径中不同值出现的次数
	    dfs(root, cnt);
	    return ans;
    }
};
```