[题目链接](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/)  
[题解链接](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solution/lc1456-fengwei2002-by-kycu-3ckd/)

https://github.com/fengwei2002/algorithm

### 1456. 定长子串中元音的最大数目

给你字符串 s 和整数 k 。

请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。

英文中的 元音字母 为（a, e, i, o, u）。

### 思路

当然，我又是大模拟，对于每一个长度为 k 的子字符串进行字符的统计

如果子字符串中有一个 元音字母，那么相同字符数就加一 

如果某个子字符串的元音字符数等于 k 了，那么可以直接结束程序


``` cpp
class Solution {
public:
    int maxVowels(string s, int k) {
        int ans = 0;

        // 找到所有长度为 k 的子字符串
        for (int i = 0, j = 0; j <= s.size();) {
            if (j - i == k) {
                string subStr = s.substr(i, j - i);
                i++, j++;
                int yuanCount = 0;
                for (int k = 0; k < subStr.size(); k++) {
                    if (subStr[k] == 'a' || subStr[k] == 'e' || subStr[k] == 'i' || subStr[k] == 'o' || subStr[k] == 'u') {
                        yuanCount++;
                    }
                }
                ans = max(ans, yuanCount);
                if (ans == k) return ans; // 剪枝
            } else {
                j++;
            }
        }
        
        return ans;
    }
};
```

![20211023124024-2021-10-23-12-40-27](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/images/20211023124024-2021-10-23-12-40-27.png)

`102/106` 数据，TLE 了，我记得之前了解过 substr 很耗时，所以想了一下，可不可以去除 substr 的操作

由于只是进行字符比对，所以可以将 substr 的代码部分调整为原有的字符串加上下标


``` cpp
class Solution {
public:
    int maxVowels(string s, int l) {
        int ans = 0;

        // 找到所有长度为 k 的子字符串
        for (int i = 0, j = 0; j <= s.size();) {
            if (j - i == l) {
                int yuanCount = 0;
                // 不使用 substr 函数，直接在 s 上执行
                for (int k = i; k < i + l; k++) {
                    if (s[k] == 'a' || s[k] == 'e' || s[k] == 'i' || s[k] == 'o' || s[k] == 'u') {
                        yuanCount++;
                    }
                }
                ans = max(ans, yuanCount);
                if (ans == l) return ans;
                i++, j++;
            } else {
                j++;
            }
        }
        
        return ans;
    }
};
```

![20211023124336-2021-10-23-12-43-38](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/images/20211023124336-2021-10-23-12-43-38.png)

ok 仍然超时hh，暴力的解决一个问题永远都不是很好的方法，每次可以想一下可不可以优化逻辑

对于这个问题，可以观察到每次考察的是一个 定长的 子字符串， 所以可以使用 **滑动窗口** 的逻辑，每次加入一个新的元素，去除前面的一个元素

同时在加入删除的过程中维护 元音字母的数量，

so：遍历字符串，如果当前位置为元音，则计数器加一；如果当前位置大于等于 k 且当前位置减 k 也是元音，则计数器减 1。更新答案。

时间复杂度：$O(n)$  
空间复杂度：仅需要常数的额外空间

``` cpp
class Solution {
   public:
    bool check(char c) {
        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';
    }
    
    int maxVowels(string s, int k) {
        int n = s.size(), cnt = 0;
        int ans = 0;

        for (int i = 0, j = 0; i < n; i++) {
            if (check(s[i])) cnt++;
            if (i >= k && check(s[i - k])) cnt--;

            ans = max(ans, cnt);
            if (ans == k) break;
        }

        return ans;
    }
};
```