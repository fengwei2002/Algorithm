[题目链接](https://leetcode.cn/problems/max-dot-product-of-two-subsequences/)  
[题解链接](https://leetcode.cn/problems/max-dot-product-of-two-subsequences/solution/lc1458-fengwei2002-by-kycu-n402/)

https://github.com/fengwei2002/algorithm

### 1458. 两个子序列的最大点积

给你两个数组 nums1 和 nums2 。

请你返回 nums1 和 nums2 中两个长度相同的 **非空** 子序列的最大点积。

数组的非空子序列是通过删除原数组中某些元素（可能一个也不删除）后剩余数字组成的序列，但不能改变数字间相对顺序。比方说，`[2,3,5]` 是 `[1,2,3,4,5]` 的一个子序列而 `[1,5,3]` 不是。

### 思路

**相关题目： 最长公共子序列**

点积的定义：

从代数角度看，先对两个数字序列中的**每组对应元素求积**，**再对所有积求和**，结果即为**点积**。从几何角度看，点积则是两个**向量的长度与它们夹角余弦的积**。 数量积

![20211023153403-2021-10-23-15-34-05](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/images/20211023153403-2021-10-23-15-34-05.png)

**第一种状态来源**
- 如果选择了 $nnums1[i]$ 和 $nums2[j]$ 并将他们形成点积，那么这两项对新点积的贡献为 $origin += nums1[i] \times nums2[j]$
  - 在选择了这一堆数字之后，前面还有 $nums1$ 的前 $i - 1$ 个元素和 $nums2$ 的前 $j - 1$ 个元素 
  - 我们可以在其中选择数字对，也可以不选择数字，因为题目中的要求只是 非空， 我们已经选择了一对元素 $nums1[i], nums2[j]$ 所以已经非空了
    - 如果在前面元素中选择数字对，$f[i][j] = f[i - 1][j - 1] + nums1[i] \times nums2[j]$
    - 如果在前面的元素中不选择数字对，$f[i][j] = nums1[i] \times nums2[j]$

**第二种状态来源**
- 不选择 $nums1[i]$ 也不选择 $nums[j]$，符合状态定义，所以状态表示为 $f[i][j] = f[i - 1][j - 1]$,

**第三种状态来源**
- 选择 $nums[i]$，不选择 $nums[j]$, 
- 这个集合表示的是 $nums1[1 \to i]$ 中选，且必须选 $nums1[i]$，从 $nums2[1\to j - 1]$ 中选
- 考虑 $f[i][j] = f[i][j - 1]$ 的来源
  - 第一个部分是选 $nums1[i]$
  - 另一个部分是不选择 $nums1[i]$
  - 所以第三种状态是 $f[i][j - 1]$ 的子集
  - 第二种状态也是 $f[i][j - 1]$ 的子集，所以第二种情况可以省略

**第四种状态来源**
- 选择 $nums[j]$，不选择 $nums[i]$, 状态表示为 $f[i][j] = f[i][j - 1]$ 原因同上

---

由于计算的是最大值，所以可以计算每个子集的值，取一个 max，就是当前的值

$$f[i][j] = max(f[i - 1][j], \\ \qquad f[i][j - 1]\\ \qquad f[i - 1][j -1] + nums1[i] \times nums2[j], \\ \qquad nums1[i] \times nums2[j])$$

$f[i][j]$ 表示的是**长度相同**的**非空**子序列的点积集合的**最大值**

``` cpp
class Solution {
public:
    int maxDotProduct(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size();
        int m = nums2.size();
        vector<vector<int>> f(n, vector<int>(m, 0));
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                int xij = nums1[i] * nums2[j];
                f[i][j] = xij;
                if (i > 0) {
                    f[i][j] = max(f[i][j], f[i - 1][j]);
                }
                if (j > 0) {
                    f[i][j] = max(f[i][j], f[i][j - 1]);
                }
                if (i > 0 && j > 0) {
                    f[i][j] = max(f[i][j], f[i - 1][j - 1] + xij);
                }
            }
        }

        return f[n - 1][m - 1];
    }
};
```

TODO 难度 DP 1458. 两个子序列的最大点积
