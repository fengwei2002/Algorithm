[竞赛链接](https://leetcode.cn/contest/biweekly-contest-72)

- T1 [题解链接](https://leetcode.cn/problems/count-equal-and-divisible-pairs-in-an-array/solution/lc2176-fengwei2002-by-konng0120-iamw/)
- T2 [题解链接](https://leetcode.cn/problems/find-three-consecutive-integers-that-sum-to-a-given-number/solution/lc2177-fengwei2002-by-konng0120-4w48/)
- T3 [题解链接](https://leetcode.cn/problems/maximum-split-of-positive-even-integers/solution/lc2178-fengwei2002-by-konng0120-tufw/)
- T4 题解链接

---


### [2176\. 统计数组中相等且可以被整除的数对](https://leetcode.cn/problems/count-equal-and-divisible-pairs-in-an-array/)


给你一个下标从 **0** 开始长度为 `n` 的整数数组 `nums` 和一个整数 `k` ，请你返回满足 `0 <= i < j < n` ，`nums[i] == nums[j]` 且 `(i * j)` 能被 `k` 整除的数对 `(i, j)` 的 **数目** 。

**示例 1：**

```
输入：nums = [3,1,2,2,2,1,3], k = 2
输出：4
解释：
总共有 4 对数符合所有要求：
- nums[0] == nums[6] 且 0 * 6 == 0 ，能被 2 整除。
- nums[2] == nums[3] 且 2 * 3 == 6 ，能被 2 整除。
- nums[2] == nums[4] 且 2 * 4 == 8 ，能被 2 整除。
- nums[3] == nums[4] 且 3 * 4 == 12 ，能被 2 整除。
```

**示例 2：**

```
输入：nums = [1,2,3,4], k = 1
输出：0
解释：由于数组中没有重复数值，所以没有数对 (i,j) 符合所有要求。
```

**提示：**

*   `1 <= nums.length <= 100`
*   `1 <= nums[i], k <= 100`


#### Solution

由于数据量很小，直接双重循环即可

``` cpp 
class Solution {
public:
    int countPairs(vector<int>& nums, int k) {
        int n = nums.size();
        int ans = 0;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (nums[i] == nums[j]) {
                    if ((i * j) % k == 0) {
                        ans++;
                    }
                }
            }
        }
        return ans;
    }
};
```

### [2177\. 找到和为给定整数的三个连续整数](https://leetcode.cn/problems/find-three-consecutive-integers-that-sum-to-a-given-number/)

给你一个整数 `num` ，请你返回三个连续的整数，它们的 **和** 为`num` 。如果 `num` 无法被表示成三个连续整数的和，请你返回一个 **空** 数组。

**示例 1：**

```
输入：num = 33
输出：[10,11,12]
解释：33 可以表示为 10 + 11 + 12 = 33 。
10, 11, 12 是 3 个连续整数，所以返回 [10, 11, 12] 。
```

**示例 2：**

```
输入：num = 4
输出：[]
解释：没有办法将 4 表示成 3 个连续整数的和。
```

**提示：**

*   `0 <= num <= 10<sup>15</sup>`


#### Solution

给定一个整数， 返回三个连续的整数，和为这个整数

不能构成返回 空数组

``` cpp 
class Solution {
public:
    vector<long long> sumOfThree(long long num) {
        typedef long long LL;
        LL st = num / 3;
        LL modVal = num % 3;

        vector<LL> ans;
        if (modVal == 0) {
            ans.push_back(st - 1);
            ans.push_back(st);
            ans.push_back(st + 1);
        }
        return ans;
    }
};
```

### [2178\. 拆分成最多数目的偶整数之和](https://leetcode.cn/problems/maximum-split-of-positive-even-integers/)


给你一个整数 `finalSum` 。请你将它拆分成若干个 **互不相同** 的偶整数之和，且拆分出来的偶整数数目 **最多** 。

*   比方说，给你 `finalSum = 12` ，那么这些拆分是 **符合要求** 的（互不相同的偶整数且和为 `finalSum`）：`(2 + 10)` ，`(2 + 4 + 6)` 和 `(4 + 8)` 。它们中，`(2 + 4 + 6)` 包含最多数目的整数。注意 `finalSum` 不能拆分成 `(2 + 2 + 4 + 4)` ，因为拆分出来的整数必须互不相同。

请你返回一个整数数组，表示将整数拆分成 **最多** 数目的偶整数数组。如果没有办法将 `finalSum` 进行拆分，请你返回一个 **空** 数组。你可以按 **任意** 顺序返回这些整数。

**示例 1：**

```
输入：finalSum = 12
输出：[2,4,6]
解释：以下是一些符合要求的拆分：(2 + 10)，(2 + 4 + 6) 和 (4 + 8) 。
(2 + 4 + 6) 为最多数目的整数，数目为 3 ，所以我们返回 [2,4,6] 。
[2,6,4] ，[6,2,4] 等等也都是可行的解。
```

**示例 2：**

```
输入：finalSum = 7
输出：[]
解释：没有办法将 finalSum 进行拆分。
所以返回空数组。
```

**示例 3：**

```
输入：finalSum = 28
输出：[6,8,2,12]
解释：以下是一些符合要求的拆分：(2 + 26)，(6 + 8 + 2 + 12) 和 (4 + 24) 。
(6 + 8 + 2 + 12) 有最多数目的整数，数目为 4 ，所以我们返回 [6,8,2,12] 。
[10,2,4,12] ，[6,2,4,16] 等等也都是可行的解。
```

**提示：**

*   `1 <= finalSum <= 10<sup>10</sup>`


#### Solution

将一个数字拆成不相等的偶整数之和，且拆分出来的数目最多

由于互不相同，所以可以从小到大进行填充，如果刚好填满目标数字，由于填充的过程中没有任何缝隙，所以就是答案

如果没有填满数字，再填一位大于目标数字了，因为目标数字是一个偶数，所以可以先将 `target - accumulate(nums.begin(), nums.end(), 0)` 填入 nums 中

现在获得了一个数组，问题转换为了如何可以获得总和相等，且数组中不再存在重复数字的数组

使用哈希表进行频率统计，如果出现了频次大于 1 的数字，累加到前面的数字即可

``` cpp
class Solution {
public:
    vector<long long> maximumEvenSplit(long long finalSum) {
        typedef long long LL;
        vector<LL> ans;
        
        if (finalSum % 2 != 0) return ans;
        
        LL sum = 0;
        LL ansSum = 0;
        while (ansSum < finalSum) {
            sum += 2;
            ans.push_back(sum);
            ansSum += sum;
        }
        
        if (ansSum != finalSum) {
            int a = ans.back();
            ans.pop_back();
            ansSum -= a;
            ans.push_back(finalSum - ansSum);
            // 弹出导致总和变大的那一个，放入差值
        }
        
        // 给定一个数组，
        // 求总和相等，其中没有重复元素的数组
        
        unordered_map<LL, int> hash;
        for (auto x : ans) hash[x]++;
        
        int nn = ans.size(); 
        for (int i = nn - 1; i > 0; i--) {
            if (hash[ans[i]] > 1) {
                ans[i - 1] = ans[i] + ans[i - 1];
                ans.pop_back();
                hash[ans[i]]--;
            }
        }

        return ans;
    }
};
```

简洁写法：

``` go 
func maximumEvenSplit(n int64) []int64 {
    ans := make([]int64, 0)
    if n % 2 == 0 {
        for i := int64(2); i <= n; i += 2 {
            ans = append(ans, i)
            n -= i
        }
        ans[len(ans) - 1] += n
        // 多出来的加到最后一个
    }
    return ans
}
```


### [2179\. 统计数组中好三元组数目](https://leetcode.cn/problems/count-good-triplets-in-an-array/)

给你两个下标从 **0** 开始且长度为 `n` 的整数数组 `nums1` 和 `nums2` ，两者都是 `[0, 1, ..., n - 1]` 的 **排列** 。

好三元组 指的是 3 个 互不相同 的值，且它们在数组 nums1 和 nums2 中出现顺序保持一致。换句话说，如果我们将 pos1v 记为值 v 在 nums1 中出现的位置，pos2v 为值 v 在 nums2 中的位置，那么一个好三元组定义为 0 <= x, y, z <= n - 1 ，且 pos1x < pos1y < pos1z 和 pos2x < pos2y < pos2z 都成立的 (x, y, z) 。

请你返回好三元组的 总数目 。

**示例 1：**

```
输入：nums1 = [2,0,1,3], nums2 = [0,1,2,3]
输出：1
解释：
总共有 4 个三元组 (x,y,z) 满足 pos1x < pos1y < pos1z ，分别是 (2,0,1) ，(2,0,3) ，(2,1,3) 和 (0,1,3) 。
这些三元组中，只有 (0,1,3) 满足 pos2x < pos2y < pos2z 。所以只有 1 个好三元组。
```

**示例 2：**

```
输入：nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3]
输出：4
解释：总共有 4 个好三元组 (4,0,3) ，(4,0,2) ，(4,1,3) 和 (4,1,2) 。
```

**提示：**

*   `n == nums1.length == nums2.length`
*   `3 <= n <= 10<sup>5</sup>`
*   `0 <= nums1[i], nums2[i] <= n - 1`
*   `nums1` 和 `nums2` 是 `[0, 1, ..., n - 1]` 的排列。


#### Solution

公共，下标递增，可以不连续，子序列，长度为 3 的总个数

学习一下：树状数组

TODO 树状数组


``` cpp 

```