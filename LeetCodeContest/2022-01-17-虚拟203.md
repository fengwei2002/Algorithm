https://leetcode-cn.com/contest/weekly-contest-203/

## A: 1560. 圆形赛道上经过次数最多的扇区

题目描述

给定一个整数 n 和一个整数数组 rounds。有一条圆形赛道由 n 个扇区组成，扇区编号从 1 到 n。现将在这条赛道上举办一场马拉松比赛，该马拉松全程由 m 个阶段组成。其中，第 i 个阶段将会从扇区 `rounds[i - 1]` 开始，到扇区 `rounds[i]` 结束。举例来说，第 1 阶段从 `rounds[0]` 开始，到 `rounds[1]` 结束。

请你以数组形式返回经过次数最多的那几个扇区，按扇区编号 升序 排列。

注意，赛道按扇区编号升序逆时针形成一个圆（请参见第一个示例）。
![20220117214641-2022-01-17-21-46-43](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/images/20220117214641-2022-01-17-21-46-43.png)
链接：https://leetcode-cn.com/problems/most-visited-sector-in-a-circular-track

``` cpp
输入：n = 4, rounds = [1,3,1,2]
输出：[1,2]
解释：本场马拉松比赛从扇区 1 开始。经过各个扇区的次序如下所示：
1 --> 2 --> 3（阶段 1 结束）
  --> 4 --> 1（阶段 2 结束）
  --> 2（阶段 3 结束，即本场马拉松结束）
其中，扇区 1 和 2 都经过了两次，它们是经过次数最多的两个扇区。
扇区 3 和 4 都只经过了一次。
```

``` cpp
输入：n = 2, rounds = [2,1,2,1,2,1,2,1,2]
输出：[2]
```

``` cpp
输入：n = 7, rounds = [1,3,5,7]
输出：[1,2,3,4,5,6,7]
```

AC 代码：

``` cpp
class Solution {
public:
    vector<int> mostVisited(int n, vector<int>& rounds) {
        vector<int> ans;
        
        vector<pair<int, int>> arr;
        for (int i = 0; i <= n; i++) {
            arr.push_back({i, 0});
        }
        
        int begin = rounds[0];
        for (int i = 1; i < rounds.size(); i++) {
            if (begin > rounds[i]) {
                int end = rounds[i] + n;
                for (int j = begin; j <= end; j++) {
                    arr[j % n].second++; 
                }
            } else {
                for (int j = begin; j <= rounds[i]; j++) {
                    arr[j].second++;
                }
            }
            begin = rounds[i] + 1;
        }
        
        arr[n].second += arr[0].second;
        arr[0].second = 0;
        
        sort(arr.begin(), arr.end(), [&](pair<int, int> a, pair<int, int> b) -> bool {
            return a.second > b.second;
        });
        
        int maxFrequency = arr[0].second;
        for (int i = 0; i < arr.size() - 1; i++) {
            // cout << arr[i].first << ' ' << arr[i].second << endl;
            if (arr[i].second == maxFrequency) {
                ans.push_back(arr[i].first);
            }
        }
        
        sort(ans.begin(), ans.end(), [&](int a, int b) -> bool {
            return a < b;
        });
        return ans;
    }
};
```

因为 arr 数组存储的 first 值等下标值，所以在存储的时候可以不用显式的写出下标值：

``` cpp 
class Solution {
public:
    vector<int> mostVisited(int n, vector<int>& rounds) {
        vector<int> s(n + 1);
        // 算头不算尾

        for (int i = 0; i + 1< rounds.size(); i++) {
            int a = rounds[i], b = rounds[i + 1];
            while (a != b) {
                s[a]++;
                a++;
                if (a > n) {
                    a -= n;
                }
            }
        }
        s[rounds.back()] ++;
        int c = 0;
        for (auto x : s) c = max(x, c);

        vector<int> ans;
        for (int i = 1; i <= n; i++) {
            if (s[i] == c) {
                ans.push_back(i);
            }
        }
        return ans;
    }
};
```

另一种方法：

因为他每一次都是从上一次的结束位置开始走的，所以：

可以发现，最后的答案至于起始位置和终止位置有关。

如果 `st` 小于等于 `ed`，则答案就是区间 `[st, ed]`。否则，答案就是区间 `[1, ed]` 并上 `[st, n]`。

``` cpp
class Solution {
public:
    vector<int> mostVisited(int n, vector<int>& rounds) {
        vector<int> ans;
        int st = rounds[0], ed = rounds[rounds.size() - 1];

        if (st > ed) {
            for (int i = 1; i <= ed; i++) {
                ans.push_back(i);
            }
            for (int i = st; i <= n; i++) {
                ans.push_back(i);
            }
        } else {
            for (int i = st; i <= ed; i++) {
                ans.push_back(i);
            }
        }
        return ans;
    }
};
```

## B: 1561. 你可以获得的最大硬币数目

https://leetcode-cn.com/problems/maximum-number-of-coins-you-can-get/

题目描述

有 3n 堆数目不一的硬币，你和你的朋友们打算按以下方式分硬币：

每一轮中，你将会选出 任意 3 堆硬币（不一定连续）。
Alice 将会取走硬币数量最多的那一堆。
你将会取走硬币数量第二多的那一堆。
Bob 将会取走最后一堆。
重复这个过程，直到没有更多硬币。
给定一个整数数组 piles，其中 piles[i] 是第 i 堆中硬币的数目。

返回你可以获得的最大硬币数目。

``` cpp
输入：piles = [2,4,1,2,7,8]
输出：9
解释：选出 (2, 7, 8) ，Alice 取走 8 枚硬币的那堆，你取走 7 枚硬币的那堆，Bob 取走最后一堆。
选出 (1, 2, 4) , Alice 取走 4 枚硬币的那堆，你取走 2 枚硬币的那堆，Bob 取走最后一堆。
你可以获得的最大硬币数目：7 + 2 = 9。
考虑另外一种情况，如果选出的是 (1, 2, 8) 和 (2, 4, 7)，
你就只能得到 2 + 4 = 6 枚硬币，这不是最优解。
```

每次拿硬币的时候，需要找到一个比当前数字小的送给 bob，需要找到一个比当前数字大的送给 alice 

``` cpp 
// 硬币数量总数是 3 的倍数
// 每次选取 3 个硬币，自己拿第二大的钱
// 结束的时候，自己手里面的钱最多
// 2 4 1 2 7 8 
// 1 2 2 4 7 8

// 1 8 7
// 2 4 2

// [9,8,7,6,5,1,2,3,4]
// 1 2 3 4 5 6 7 8 9
// 1 9 8
// 2 7 6
// 3 5 4
class Solution {
public:
    int maxCoins(vector<int>& piles) {
        int ans = 0;
        sort(piles.begin(), piles.end(), [&](int a, int b) -> bool {
             return a < b;
        });
        
        int aIndex = 0;
        int bIndex = piles.size() - 2;
        int cIndex = piles.size() - 1;
        for (int i = 0; i < piles.size() / 3; i++) {
            auto a = piles[aIndex];
            auto b = piles[bIndex];
            auto c = piles[cIndex];
            ans += b;

            bIndex -= 2;

        }
        
        return ans;
    }
};
```

## C: 1562. 查找大小为 M 的最新分组

https://leetcode-cn.com/problems/find-latest-group-of-size-m/

题目描述
给定一个数组 arr，该数组表示一个从 1 到 n 的数字排列。有一个长度为 n 的二进制字符串，该字符串上的所有位最初都设置为 0。

在从 1 到 n 的每个步骤 i 中（假设二进制字符串和 arr 都是从 1 开始索引的情况下），二进制字符串上位于位置 arr[i] 的位将会设为 1。

给你一个整数 m，请你找出二进制字符串上存在长度为 m 的一组 1 的最后步骤。一组 1 是一个连续的、由 1 组成的子串，且左右两边不再有可以延伸的 1。

返回存在长度 恰好 为 m 的 一组 1 的最后步骤。如果不存在这样的步骤，请返回 -1。

样例：

``` cpp
输入：arr = [3,5,1,2,4], m = 1
输出：4
解释：
步骤 1："00100"，由 1 构成的组：["1"]
步骤 2："00101"，由 1 构成的组：["1", "1"]
步骤 3："10101"，由 1 构成的组：["1", "1", "1"]
步骤 4："11101"，由 1 构成的组：["111", "1"]
步骤 5："11111"，由 1 构成的组：["11111"]
存在长度为 1 的一组 1 的最后步骤是步骤 4。
```


``` cpp 
输入：arr = [3,1,5,4,2], m = 2
输出：-1
解释：
步骤 1："00100"，由 1 构成的组：["1"]
步骤 2："10100"，由 1 构成的组：["1", "1"]
步骤 3："10101"，由 1 构成的组：["1", "1", "1"]
步骤 4："10111"，由 1 构成的组：["1", "111"]
步骤 5："11111"，由 1 构成的组：["11111"]
不管是哪一步骤都无法形成长度为 2 的一组 1。
```

这个题读题读错意思了，所以没有过

lc 352 题


``` cpp

```

