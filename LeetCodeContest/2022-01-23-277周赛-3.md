
## A: 5989. 元素计数

[原题链接](https://leetcode.cn/problems/count-elements-with-strictly-smaller-and-greater-elements/)

### 题目描述

给你一个整数数组 nums ，统计并返回在 nums 中同时具有一个严格较小元素和一个严格较大元素的元素数目。

### 思路

一个集合中存在一个元素比这个元素小的值，只需要最小值小即可，最大值同理 `O(n) 可以实现`， 但是 sort 一遍写起来会更加简单

### 代码

``` cpp
class Solution {
public:
    int countElements(vector<int>& nums) {
        sort(nums.begin(), nums.end());

        int ans = 0;
        for (auto x : nums) {
            if (x > nums[0] && x < nums.back()) {
                ans++;
            }
        }

        return ans;
    }
};
```

当然也可以进行双指针的模拟：

``` cpp
class Solution {
public:
    int countElements(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        
        int cnt = 0;
        for (int i = 0; i < nums.size(); i++) {
            int j = i - 1;
            int k = i + 1;
            while (j >= 0 && nums[j] == nums[i]) {
                j--;
            }
            while (k < nums.size() && nums[k] == nums[i]) {
                k++;
            }

            if (j >= 0 && k < nums.size() && nums[j] < nums[i] && nums[k] > nums[i]) {
                cnt++;
            }
        }
        return cnt;
    }
};
```

---

## B: 5991. 按符号重排数组

[原题链接](https://leetcode.cn/problems/rearrange-array-elements-by-sign/)

### 题目描述

给你一个下标从 0 开始的整数数组 nums ，数组长度为 偶数 ，由数目相等的正整数和负整数组成。

你需要 重排 nums 中的元素，使修改后的数组满足下述条件：

任意 连续 的两个整数 符号相反
对于符号相同的所有整数，保留 它们在 nums 中的 顺序 。
重排后数组以正整数开头。
重排元素满足上述条件后，返回修改后的数组。

### 思路

分成两组，放入最终结果中即可

### 代码

``` cpp
class Solution {
public:
    vector<int> rearrangeArray(vector<int>& nums) {
        vector<int> ans(nums.size());
        
        int i = 0, j = 1;   
        for (auto x : nums) {
            if (x > 0) {
                ans[i] = x;
                i += 2;
            } else {
                ans[j] = x;
                j += 2;
            }
        }

        return ans;
    }
};
```

``` cpp 
class Solution {
public:
    vector<int> rearrangeArray(vector<int>& nums) {
        vector<int> r;
        vector<int> l;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > 0) {
                r.push_back(nums[i]);
            } else {
                l.push_back(nums[i]);
            }
        }
        
        vector<int> ans;
        int rIndex = 0;
        int lIndex = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (i % 2 == 0) {
                ans.push_back(r[rIndex]);
                rIndex++;
            } else {
                ans.push_back(l[lIndex]);
                lIndex++;
            }
        }
        return ans;
    }
};
```

---

## C: 5990. 找出数组中的所有孤独数字

[原题链接](https://leetcode.cn/problems/find-all-lonely-numbers-in-the-array/)

### 题目描述

给你一个整数数组 nums 。如果数字 x 在数组中仅出现 一次 ，且没有 相邻 数字（即，x + 1 和 x - 1）出现在数组中，则认为数字 x 是 孤独数字 。

返回 nums 中的 所有 孤独数字。你可以按 任何顺序 返回答案。

### 代码

``` cpp
class Solution {
public:
    vector<int> findLonely(vector<int>& nums) {
        vector<int> ans;
        unordered_map<int, int> hash;
        for (int i = 0; i < nums.size(); i++) {
            hash[nums[i]]++;
        }
        
        vector<int> temp;
        for (auto &[k, v] : hash) {
            if (v == 1) {
                temp.push_back(k);
            }
        }

        for (int i = 0; i < temp.size(); i++) {
            if (hash.count(temp[i] - 1) != 1 && hash.count(temp[i] + 1) != 1) {
                ans.push_back(temp[i]);
            }
        }
        return ans;
    }
};

// 只出现一次，并且左侧数字没有出现，右侧数字没有出现
```

``` cpp 
class Solution {
public:
    vector<int> findLonely(vector<int>& nums) {
        unordered_map<int, int> hash;
        vector<int> ans;
        for (auto x : nums) {
            hash[x]++;
        }
        for (auto &[k, v] : hash) {
            if (v == 1 && hash[k + 1] == 0 && hash[k - 1] == 0) {
                ans.push_back(k);
            }
        }
        return ans;
    }
};
```

---

## D: 5992. 基于陈述统计最多好人数

[原题链接](https://leetcode.cn/problems/maximum-good-people-based-on-statements/)

### 题目描述

游戏中存在两种角色：

好人：该角色只说真话。
坏人：该角色可能说真话，也可能说假话。
给你一个下标从 0 开始的二维整数数组 statements ，大小为 n x n ，表示 n 个玩家对彼此角色的陈述。具体来说，statements[i][j] 可以是下述值之一：

0 表示 i 的陈述认为 j 是 坏人 。 
1 表示 i 的陈述认为 j 是 好人 。
2 表示 i 没有对 j 作出陈述。
另外，玩家不会对自己进行陈述。形式上，对所有 0 <= i < n ，都有 statements[i][i] = 2 。

根据这 n 个玩家的陈述，返回可以认为是 好人 的 最大 数目。

### 思路

没有做出来，看题解：

--- 

因为最多有 15 个人 (n<=15) ，所以此题用二进制枚举或者 DFS 暴搜都是可以求解的。

枚举或者搜索的关键在于：我们**只判断好人的陈词**，并不判断坏人的陈述（**因为坏人无论是说真还是说假都无法提高好人的个数，对答案没有贡献**）

我们可以使用二进制的0和1分别表示这个人是坏人还是好人。
如果存在15个人，那么我们需要15个二进制位就可以表示这15个人好坏的所有组合,如图所示：

![20220123170640-2022-01-23-17-06-40](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/images/20220123170640-2022-01-23-17-06-40.png)

这样我们只需要遍历这其中的所有情况，并验证其中某种情况下是不是满足题目的要求，如果满足，就求出其中好人的个数，并取最大值即可


二进制枚举的方法就是通过二进制数 mask 的每一位表示第 i 个人是好人还是坏人，所以这个 mask 表示的是所有人的状态，我们只需枚举所有的可能性，然后判断该可能性下是否存在矛盾，矛盾有以下 2 种情况：

> 好人陈述的坏人在mask状态里面其实是好人
> 好人陈述的好人在mask状态里面其实是坏人

遇上这2种情况我们就可以快进到下一种方案中，其他合法情况我们通过方法`__builtin_popcount`求出mask这个二进制状态里面1的个数即可，在所有合法情况里面取max就是答案。

枚举 n 个人， 谁是好人，谁是坏人的话，一共存在 2^n 种不同的情况

用 1 表示好人，用 0 表示坏人，这样就可以枚举 0 到 2^n - 1 中的所有的数字



### 代码

``` cpp
class Solution {
public:
    int maximumGood(vector<vector<int>>& s) {
        int n = s.size();
        int mask = (1 << n); 
        int ans = 0;
        for (int i = 0; i < mask; i++) {  // 考虑 0 到 2^n - 1 种情况中的值
            bool flag = true;
            for (int j = 0; j < n; j++) { // 对于每一个值考虑每一位具体是 0 还是 1 
                if ((i >> j) & 1) {       // 如果 i 的第 j 位等于 1, 就说明这种 mask 中的这一位存在
                                          // j 是好人的情况下，根据 statesment[j][k] 计算其他人是好人还是坏人
                    for (int k = 0; k < s[j].size(); k++) {
                        if (s[j][k] == 2) continue;
                        if ((s[j][k] == 1 && ((i >> k) & 1) == 0) 
                        || (s[j][k] == 0 && ((i >> k) & 1) == 1)) {
                                           // 如果出现了陈述的状态和当前 mask 表示的状态不同的情况
                            flag = false;  
                            break;         // 就可以快进到下一种情况
                        }
                    }
                }
            }
            if (flag) {                    // 如果存在一种 mask 正确的遍历完成的话
                ans = max(ans, __builtin_popcount(i));
            }
        }
        return ans;
    }
};
```


不使用二进制状态压缩，使用递归回溯解决：

- 采用递归回溯的方式按编号从小到大依次枚举每个人的身份。
- 如果确定了第 i 个人的身份，则需要核实第 i 个人的身份是否与 0 到 i − 1 的人描述相符。

``` cpp 
class Solution {
public:
    int ans = 0;
    vector<int> p;

    bool check(int i, const vector<vector<int>>& st) {
        // check 函数根据 i 和已知的陈述进行搜索
        // 因为是从前向后进行的遍历，所以前面的状态是确定的 [0 ~ i]，只考虑前面就可以
        for (int j = 0; j < i; j++) {
            if (p[i] == 1 && st[i][j] != 2 && p[j] != st[i][j]) {
                return false; 
            } // 如果 i 是好人，并且 j 的身份和 i 的言论冲突， return false

            if (p[j] == 1 && st[j][i] != 2 && p[i] != st[j][i]) {
                return false;
            } // 如果某种情况下 j 是好人，并且 i 是好人且和 j 的言论冲突， return false
        }

        return true;
    }

    void solve(int i, int n, int sum, const vector<vector<int>>& st) {
        if (i == n) { // 如果某一种情况遍历到了最后一个人之后， 就使用好人的数量更新一次 ans 的值
            ans = max(ans, sum);
            return;
        }

        p[i] = 1; // 如果 p[i] 等于 1， 并且和已知的条件不冲突， 考虑下一个人， 好人的数量 sum + 1
        if (check(i, st)) {
            solve(i + 1, n, sum + 1, st);
        }

        p[i] = 0; // 如果 p[i] 等于 0， 并且和已知条件不冲突，考虑下一个人，好人的数量 sum 不变
        if (check(i, st)) {
            solve(i + 1, n, sum, st);
        }

        return;
    }

    int maximumGood(vector<vector<int>>& statements) {
        const int n = statements.size();
        p.resize(n);

        solve(0, n, 0, statements);
        // 从 0 到 n 枚举每个人的身份 sum 统计好人的数目

        return ans;
    }
};
```

### 反思

如果坏人只说假话：

[codeforces 1594D](https://codeforces.com/problemset/problem/1594/D)