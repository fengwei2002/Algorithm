- [T1 minimum-sum-of-four-digit-number-after-splitting-digits](https://leetcode-cn.com/problems/minimum-sum-of-four-digit-number-after-splitting-digits/solution/dfs-by-konng0120-dei9/) 
- [T2 partition-array-according-to-given-pivot](https://leetcode-cn.com/problems/partition-array-according-to-given-pivot/solution/t2-fengwei2002-by-konng0120-28z1/)

--- 

- [T3 设置时间的最少代价](https://leetcode-cn.com/problems/minimum-cost-to-set-cooking-time/solution/lc5986-fengwei2002-t3-fen-lei-tao-lun-by-5p9u/)

输入四个数字，代表目标加热时间

一开始，你的手指在数字 startAt 处。
将手指移到 任何其他数字 ，需要花费 moveCost 的单位代价。
每 输入你手指所在位置的数字一次，需要花费 pushCost 的单位代价。

分类讨论：（题目总是设置为目标秒数，而不是包含目标秒数，所以就可以分类讨论而不是暴搜）

因为秒数的范围 `[0,99]`, 分两种场景讨论：
- `mins = target / 60, secs = target % 60;`
- `mins = target / 60 - 1, secs = target % 60 + 60;`
将 `mins * 100 + secs` 转为字符串进行处理，求出花费的时间即可；
``` cpp 
class Solution {
public:
    int minCostSetTime(int startAt, int moveCost, int pushCost, int targetSeconds) {
        int minuteCount = targetSeconds / 60;
        int secondCount = targetSeconds % 60;
        int ans1 = cal(startAt, moveCost, pushCost, minuteCount, secondCount);
        int ans2 = cal(startAt, moveCost, pushCost, minuteCount - 1, secondCount + 60);
        return min(ans1, ans2);
    }

    int cal(int startAt, int moveCost, int pushCost, int minuteCount, int secondCount) {
        if (minuteCount > 99 || secondCount > 99 || minuteCount < 0) { 
            // minuteCount < 0 是为了去除 minuteCount - 1 小于 0  的情况
            return INT_MAX; // 代表这种情况不可能出现
        }

        string s = to_string(minuteCount * 100 + secondCount);

        int ans = 0;
        for (int i = 0; i < s.size(); i++) {
            if (startAt == s[i] - '0') {
                ans += pushCost;
            } else {
                ans += moveCost + pushCost;
            }
            startAt = s[i] - '0';
        }
        return ans;
    }
};
```

- T4 删除元素后和的最小差值

### [5987\. 删除元素后和的最小差值](https://leetcode-cn.com/problems/minimum-difference-in-sums-after-removal-of-elements/)

给你一个下标从 **0** 开始的整数数组 `nums` ，它包含 `3 * n` 个元素。

你可以从 `nums` 中删除 **恰好** `n` 个元素，剩下的 `2 * n` 个元素将会被分成两个 **相同大小** 的部分。

*   前面 `n` 个元素属于第一部分，它们的和记为 `sum<sub style="display: inline;">first</sub>` 。
*   后面 `n` 个元素属于第二部分，它们的和记为 `sum<sub style="display: inline;">second</sub>` 。

两部分和的 **差值** 记为 `sum<sub style="display: inline;">first</sub> - sum<sub style="display: inline;">second</sub>` 。

*   比方说，`sum<sub style="display: inline;">first</sub> = 3` 且 `sum<sub style="display: inline;">second</sub> = 2` ，它们的差值为 `1` 。
*   再比方，`sum<sub style="display: inline;">first</sub> = 2` 且 `sum<sub style="display: inline;">second</sub> = 3` ，它们的差值为 `-1` 。

请你返回删除 `n` 个元素之后，剩下两部分和的 **差值的最小值** 是多少。

**示例 1：**

``` cpp
输入：nums = [3,1,2]
输出：-1
解释：nums 有 3 个元素，所以 n = 1 。
所以我们需要从 nums 中删除 1 个元素，并将剩下的元素分成两部分。
- 如果我们删除 nums[0] = 3 ，数组变为 [1,2] 。两部分和的差值为 1 - 2 = -1 。
- 如果我们删除 nums[1] = 1 ，数组变为 [3,2] 。两部分和的差值为 3 - 2 = 1 。
- 如果我们删除 nums[2] = 2 ，数组变为 [3,1] 。两部分和的差值为 3 - 1 = 2 。
两部分和的最小差值为 min(-1,1,2) = -1 。
```

**示例 2：**

``` cpp
输入：nums = [7,9,5,8,1,3]
输出：1
解释：n = 2 。所以我们需要删除 2 个元素，并将剩下元素分为 2 部分。
如果我们删除元素 nums[2] = 5 和 nums[3] = 8 ，剩下元素为 [7,9,1,3] 。和的差值为 (7+9) - (1+3) = 12 。
为了得到最小差值，我们应该删除 nums[1] = 9 和 nums[4] = 1 ，剩下的元素为 [7,5,8,3] 。和的差值为 (7+5) - (8+3) = 1 。
观察可知，最优答案为 1 。
```

**提示：**

*   `nums.length == 3 * n`
*   `1 <= n <= 10<sup>5</sup>`
*   `1 <= nums[i] <= 10<sup>5</sup>`

---

思路就是把所有可能的 **分界点** 都遍历一次，不管怎么花里胡哨都要分成两段，那这两端的分界点只有 3n 中间的那 n 个可能

左半部分的最小和减去有伴部分的最大和就是两部分和的最小差值

枚举所有拆分位置，所有差值的最小值就是答案

前 i 个元素中的最小的 n 个元素的和 
后 i 个元素中的最大的 n 个元素的和 

计算前缀最小和的时候，可以维护一个包含 n 个元素的最大堆，不断向右遍历 nums 中的元素 v，计算 v 时刻的前缀最小和，如果 v 比堆定元素小，则弹出堆顶元素，并将 v 入队

计算后缀最大和，维护一个包含 n 个元素的最小堆，不断向左遍历 nums 中的元素 v， 计算 v 时刻的后缀最大和， 如果 v 比堆顶的元素大，则弹出堆顶元素，并将 v 放入 堆中 


``` cpp 
class Solution {
public:
    typedef long long LL;
    LL minimumDifference(vector<int>& nums) {
        int n = nums.size();
        int k = n / 3;

        vector<LL> leftSum(n, 0);
        priority_queue<int, vector<int>, less<int>> minPQ;

        for (int i = 0; i < 2 * k; i++) {
            if (i == 0) {
                leftSum[i] = 0;
            } else {
                leftSum[i] = leftSum[i - 1];
            }

            minPQ.push(nums[i]);
            leftSum[i] += nums[i];
            if (minPQ.size() > k) {
                leftSum[i] -= minPQ.top();
                minPQ.pop();
            }
        }

        vector<LL> rightSum(n, 0);
        priority_queue<int, vector<int>, greater<int>> maxPQ;
        
        for (int i = n - 2; i >= k - 1; i--) {
            rightSum[i] = rightSum[i + 1];

            maxPQ.push(nums[i + 1]);
            rightSum[i] += nums[i + 1];
            if (maxPQ.size() > k) {
                rightSum[i] -= maxPQ.top();
                maxPQ.pop();
            }
        }
       
        LL ans = 1e15;
        for (int i = k - 1; i <= 2 * k - 1; i++) {
            ans = min(ans, leftSum[i] - rightSum[i]);
        }
        return ans;
    }
};
```

[题解](https://leetcode-cn.com/problems/minimum-difference-in-sums-after-removal-of-elements/solution/lc2163-fengwei2002-by-konng0120-4r99/)