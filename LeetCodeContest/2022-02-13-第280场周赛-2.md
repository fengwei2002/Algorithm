- [T1](https://leetcode.cn/problems/count-operations-to-obtain-zero/solution/lct1-fengwei2002-by-konng0120-mbgo/)
- T2

### [6005\. 使数组变成交替数组的最少操作数](https://leetcode.cn/problems/minimum-operations-to-make-the-array-alternating/)

给你一个下标从 **0** 开始的数组 `nums` ，该数组由 `n` 个正整数组成。

如果满足下述条件，则数组 `nums` 是一个 **交替数组** ：

* `nums[i - 2] == nums[i]` ，其中 `2 <= i <= n - 1` 。
* `nums[i - 1] != nums[i]` ，其中 `1 <= i <= n - 1` 。

在一步 **操作** 中，你可以选择下标 `i` 并将 `nums[i]` **更改** 为 **任一** 正整数。

返回使数组变成交替数组的 **最少操作数** 。

**示例 1：**

```
输入：nums = [3,1,3,2,4,3]
输出：3
解释：
使数组变成交替数组的方法之一是将该数组转换为 [3,1,3,1,3,1] 。
在这种情况下，操作数为 3 。
可以证明，操作数少于 3 的情况下，无法使数组变成交替数组。
```

**示例 2：**

```
输入：nums = [1,2,2,2,2]
输出：2
解释：
使数组变成交替数组的方法之一是将该数组转换为 [1,2,1,2,1].
在这种情况下，操作数为 2 。
注意，数组不能转换成 [2,2,2,2,2] 。因为在这种情况下，nums[0] == nums[1]，不满足交替数组的条件。
```

**提示：**

* `1 <= nums.length <= 10<sup>5</sup>`
* `1 <= nums[i] <= 10<sup>5</sup>`

#### Solution

[参考：0x3f](https://leetcode.cn/problems/minimum-operations-to-make-the-array-alternating/solution/tan-xin-fen-lei-tao-lun-by-endlesscheng-qj15/)

给定一个数组，求将这个数组变为交替数组的最小步数

根据题意，按照奇偶下标分组，记为 $a0$ 和 $a1$ 每组内的元素需要相等

考虑每组内出现次数最多的数字，记为 x 和 y

- 如果 x 不等于 y 那么 a0 需要保留x ，a1 需要保留 y 其余元素都需要做修改
- 如果 x 等于 y， 那么可以考虑每组内出现次数第二多的元素，分别记为 x1 和 y1。
  - 那么 a0 可以保留 x a1 保留 y1 或者 a0 保留 x1， a0 保留 y  
  - 取这两种情况的最大值，保留

```go
type pair struct{num, cnt int}

func getMaxCnt2(cnt map[int]int) []pair { 
    a := make([]pair, 0, max(len(cnt), 2))
    for num, c := range cnt {
        a = append(a, pair{num, c})
    }
    sort.Slice(a, func(i, j int) bool { return a[i].cnt > a[j].cnt })
    return a[:2] // 不足两个时，用 pair{0, 0} 填充

}

func minimumOperations(nums []int) int {
    cnt := [2]map[int]int {{}, {}}  // 开辟两个 hash
    for i, num := range nums {  // 按照下标的奇数和偶数统计每个数字出现的次数
        cnt[i & 1][num]++
    }

    a0 := getMaxCnt2(cnt[0])    // 求出偶数下标中出现次数最多的值，以及具体的频次
    a1 := getMaxCnt2(cnt[1])    // 求出奇数下标中出现次数最多的值，以及具体的频次

    if a0[0].num != a1[0].num { // 如果两个分组中选出的数字不相等
        return len(nums) - a0[0].cnt - a1[0].cnt
    }                           // 返回将其他数字变为这两个数字的步数

    return len(nums) - max(a0[0].cnt + a1[1].cnt, a0[1].cnt + a1[0].cnt)
    // 相等时, 保留出现次数第二多的数字 和另一个出现次数次多的
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

CPP version

```cpp
class Solution {
public:
    typedef pair<int, int> PII;
    int minimumOperations(vector<int>& nums) {
        unordered_map<int, int> cnt0, cnt1;
        for (int i = 0; i < nums.size(); i++) {
            if (i&1) cnt1[nums[i]]++;
            else cnt0[nums[i]]++;
        }

        auto getMaxCnt2 = [&](unordered_map<int, int> hash) {
            vector<PII> a;
            for (auto &[k, v] : hash) {
                a.push_back({k ,v});
            }
            sort(a.begin(), a.end(), [&](const PII x, const PII y) {
                return x.second > y.second; 
            });
            a.resize(2);
            return a;
        };

        auto a0 = getMaxCnt2(cnt0);
        auto a1 = getMaxCnt2(cnt1);

        if (a0[0].first != a1[0].first) {
            return nums.size() - a0[0].second - a1[0].second;
        }
        // 相等时，保留 出现次数最多的值，和相邻数组中出现次数第二多的值 中更大的一个
        int maxVal = max(a0[0].second + a1[1].second, a0[1].second + a1[0].second);
        return nums.size() - maxVal;
    }
};
```

- T3 

类似于一个城市天际线的问题

拿出最少数目的魔法豆

### [6006\. 拿出最少数目的魔法豆](https://leetcode.cn/problems/removing-minimum-number-of-magic-beans/)

给你一个 **正** 整数数组 `beans` ，其中每个整数表示一个袋子里装的魔法豆的数目。

请你从每个袋子中 **拿出** 一些豆子（也可以** 不拿出**），使得剩下的 **非空** 袋子中（即 **至少** 还有 **一颗** 魔法豆的袋子）魔法豆的数目 **相等** 。一旦魔法豆从袋子中取出，你不能将它放到任何其他的袋子中。

请你返回你需要拿出魔法豆的 **最少数目**。

**示例 1：**

```
输入：beans = [4,1,6,5]
输出：4
解释：
- 我们从有 1 个魔法豆的袋子中拿出 1 颗魔法豆。
  剩下袋子中魔法豆的数目为：[4,0,6,5]
- 然后我们从有 6 个魔法豆的袋子中拿出 2 个魔法豆。
  剩下袋子中魔法豆的数目为：[4,0,4,5]
- 然后我们从有 5 个魔法豆的袋子中拿出 1 个魔法豆。
  剩下袋子中魔法豆的数目为：[4,0,4,4]
总共拿出了 1 + 2 + 1 = 4 个魔法豆，剩下非空袋子中魔法豆的数目相等。
没有比取出 4 个魔法豆更少的方案。
```

**示例 2：**

```
输入：beans = [2,10,3,2]
输出：7
解释：
- 我们从有 2 个魔法豆的其中一个袋子中拿出 2 个魔法豆。
  剩下袋子中魔法豆的数目为：[0,10,3,2]
- 然后我们从另一个有 2 个魔法豆的袋子中拿出 2 个魔法豆。
  剩下袋子中魔法豆的数目为：[0,10,3,0]
- 然后我们从有 3 个魔法豆的袋子中拿出 3 个魔法豆。
  剩下袋子中魔法豆的数目为：[0,10,0,0]
总共拿出了 2 + 2 + 3 = 7 个魔法豆，剩下非空袋子中魔法豆的数目相等。
没有比取出 7 个魔法豆更少的方案。
```

**提示：**

* `1 <= beans.length <= 10<sup>5</sup>`
* `1 <= beans[i] <= 10<sup>5</sup>`

#### Solution

可以将 beans 从小到大进行排序后，枚举最终非空袋子中魔法豆的数目 v  
将小于 v 的魔法豆子全部清空，大于 v 的魔法都减少至 v 
这样所有的非空袋子中的魔法都就都相等了

> 想请教一下，这个题如果是，可以从一部分的袋子中拿去豆子，可以在一部分的袋子中放入豆子

设数组 beans 的长度为 n 对于第 i 个袋子，我们可以至多保留 $(n - i) * beans[i]$ 个魔法豆 

用 beans 的总和减去 [保留的魔法豆] 就是 [答案]

求 [答案] 中的最小值,

设数组 beans 的长度为 n 对于第 i 个袋子，我们可以至多保留 

$$
(n - i) \times beans
$$

因为已经排序，也就是把大于 beans 后面的元素全部砍到 beans 大小， 记总 beans 的个数为 k
前面的元素全部扔到 0 

首先全部扔到 0，记为 sum 

然后再根据每个值作为水平线，放入 k 个水平线高度的 beans

那么答案就是 `sum - k * beans `

![20220213172905-2022-02-13-17-29-08](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/images/20220213172905-2022-02-13-17-29-08.png)

```go
func minimumRemoval(beans []int) int64 {
    sort.Ints(beans)
    sum, mx := 0, 0
    for i, v := range beans {
        sum += v
        mx = max(mx, (len(beans)-i)*v)
    }
    return int64(sum - mx)
}

func max(a, b int) int { if b > a { return b }; return a }
```

```py
class Solution:
    def minimumRemoval(self, beans: List[int]) -> int:
        a = sum(beans)

        beansN = []
        for i, v in enumerate(sorted(beans)):
            beansN.append((len(beans) - i) * v)
        return a - max(beansN)
```

- T4 

### [6007\. 数组的最大与和](https://leetcode.cn/problems/maximum-and-sum-of-array/)

给你一个长度为 `n` 的整数数组 `nums` 和一个整数 `numSlots` ，满足`2 * numSlots >= n` 。总共有 `numSlots` 个篮子，编号为 `1` 到 `numSlots` 。

你需要把所有 `n` 个整数分到这些篮子中，且每个篮子 **至多** 有 2 个整数。一种分配方案的 **与和** 定义为每个数与它所在篮子编号的 **按位与运算** 结果之和。

* 比方说，将数字 `[1, 3]` 放入篮子 **_`1`_** 中，`[4, 6]` 放入篮子 **_`2`_** 中，这个方案的与和为 `(1 AND **_1_**) + (3 AND **_1_**) + (4 AND _**2**_) + (6 AND _**2**_) = 1 + 1 + 0 + 2 = 4` 。

请你返回将 `nums` 中所有数放入`numSlots` 个篮子中的最大与和。

**示例 1：**

```
输入：nums = [1,2,3,4,5,6], numSlots = 3
输出：9
解释：一个可行的方案是 [1, 4] 放入篮子 1 中，[2, 6] 放入篮子 2 中，[3, 5] 放入篮子 3 中。
最大与和为 (1 AND 1) + (4 AND 1) + (2 AND 2) + (6 AND 2) + (3 AND 3) + (5 AND 3) = 1 + 0 + 2 + 2 + 3 + 1 = 9 。
```

**示例 2：**

```
输入：nums = [1,3,10,4,7,1], numSlots = 9
输出：24
解释：一个可行的方案是 [1, 1] 放入篮子 1 中，[3] 放入篮子 3 中，[4] 放入篮子 4 中，[7] 放入篮子 7 中，[10] 放入篮子 9 中。
最大与和为 (1 AND 1) + (1 AND 1) + (3 AND 3) + (4 AND 4) + (7 AND 7) + (10 AND 9) = 1 + 1 + 3 + 4 + 7 + 8 = 24 。
注意，篮子 2 ，5 ，6 和 8 是空的，这是允许的。
```

**提示：**

* `n == nums.length`
* `1 <= numSlots <= 9`
* `1 <= n <= 2 * numSlots`
* `1 <= nums[i] <= 15`

TODO 状态压缩 DP   
