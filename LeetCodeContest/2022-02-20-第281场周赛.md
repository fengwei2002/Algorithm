[竞赛链接](https://leetcode.cn/contest/weekly-contest-281/)

- T1 [题解链接](https://leetcode.cn/problems/count-integers-with-even-digit-sum/solution/lc2180-fengwei2002-by-konng0120-0i93/)
- T2 [题解链接](https://leetcode.cn/problems/merge-nodes-in-between-zeros/solution/lc2181-fengwei2002-by-konng0120-3rhr/)
- T3 [题解链接](https://leetcode.cn/problems/construct-string-with-repeat-limit/solution/lc2182-fengwei2002-by-konng0120-cm2r/)
- T4 题解链接

---


### [2180\. 统计各位数字之和为偶数的整数个数](https://leetcode.cn/problems/count-integers-with-even-digit-sum/)


给你一个正整数 `num` ，请你统计并返回 **小于或等于** `num` 且各位数字之和为 **偶数** 的正整数的数目。

正整数的 **各位数字之和** 是其所有位上的对应数字相加的结果。

**示例 1：**

```
输入：num = 4
输出：2
解释：
只有 2 和 4 满足小于等于 4 且各位数字之和为偶数。    
```

**示例 2：**

```
输入：num = 30
输出：14
解释：
只有 14 个整数满足小于等于 30 且各位数字之和为偶数，分别是： 
2、4、6、8、11、13、15、17、19、20、22、24、26 和 28 。
```

**提示：**

*   `1 <= num <= 1000`


#### Solution


``` cpp 
class Solution {
public:
    int countEven(int num) {
        int ans = 0;
        for (int i = 1; i <= num; i++) {
            if (check(i)) {
                ans++;
            }
        }
        return ans;
    }

    bool check(int x) {
        int sum = 0;
        while (x > 0) {
            sum += x % 10;
            x /= 10;
        }
        
        if (sum % 2 != 0) return false;
        
        return true;
    }
};
```

### [2181\. 合并零之间的节点](https://leetcode.cn/problems/merge-nodes-in-between-zeros/)


给你一个链表的头节点 `head` ，该链表包含由 `0` 分隔开的一连串整数。链表的 **开端** 和 **末尾** 的节点都满足 `Node.val == 0` 。

对于每两个相邻的 `0` ，请你将它们之间的所有节点合并成一个节点，其值是所有已合并节点的值之和。然后将所有 `0` 移除，修改后的链表不应该含有任何 `0` 。

 返回修改后链表的头节点 `head` 。

**示例 1：  
![](https://assets.leetcode.com/uploads/2022/02/02/ex1-1.png)**

```
输入：head = [0,3,1,0,4,5,2,0]
输出：[4,11]
解释：
上图表示输入的链表。修改后的链表包含：
- 标记为绿色的节点之和：3 + 1 = 4
- 标记为红色的节点之和：4 + 5 + 2 = 11
```

**示例 2：  
![](https://assets.leetcode.com/uploads/2022/02/02/ex2-1.png)**

```
输入：head = [0,1,0,3,0,2,2,0]
输出：[1,3,4]
解释：
上图表示输入的链表。修改后的链表包含：
- 标记为绿色的节点之和：1 = 1
- 标记为红色的节点之和：3 = 3
- 标记为黄色的节点之和：2 + 2 = 4
```

**提示：**

*   列表中的节点数目在范围 `[3, 2 * 10<sup>5</sup>]` 内
*   `0 <= Node.val <= 1000`
*   **不** 存在连续两个 `Node.val == 0` 的节点
*   链表的 **开端** 和 **末尾** 节点都满足 `Node.val == 0`


#### Solution

给定一个链表，将链表中的成段出现的非零段合并为一个 node，返回合并之后的链表

思路：
- 从前向后遍历，如果 node 的节点为 0 则删除，
- 如果找到了一个节点的下一个节点的值为 0，那么开始记录
- 从记录点向后走到最后一个不为 0 的点，统计记录点到最后一个点之间的总和
- 创建新节点，插入到记录点的后面
- 循环执行直到到达链表的尾结点

因为要进行链表拼接的操作（需要用到一个 node 的前一个节点，所以使用 dummy 节点指向 head，考察 `cur->next`）

设 `cur->next` 的初始值为 0

当 `cur->next` 的值为 0 时：

![konng0120-2022-02-20-第281场周赛-2022-02-22-22-02-18](https://raw.githubusercontent.com/psychonaut1f/a/main/img/konng0120-2022-02-20-%E7%AC%AC281%E5%9C%BA%E5%91%A8%E8%B5%9B-2022-02-22-22-02-18.png)


当 `cur->next` 的值不为 0 时：

![konng0120-2022-02-20-第281场周赛-2022-02-22-22-10-34](https://raw.githubusercontent.com/psychonaut1f/a/main/img/konng0120-2022-02-20-%E7%AC%AC281%E5%9C%BA%E5%91%A8%E8%B5%9B-2022-02-22-22-10-34.png)

所以可以写出一份优美的代码：

``` cpp 
class Solution {
public:
    ListNode* mergeNodes(ListNode* head) {
        auto dummy = new ListNode(-1, head);
        auto cur = dummy;
        while (cur->next != nullptr) {
            if (cur->next->val == 0) {
                cur->next = cur->next->next; // 删除 0 节点
            } else {
                auto subHead = cur->next;    // 否则 cur->next->val != 0 
                                             // 记录拼接链表的头节点, cur->next 应该等于新的头节点
                long long sum = 0;
                while (subHead != nullptr && subHead->val != 0) {
                    sum += subHead->val;
                    subHead = subHead->next;
                }
                auto newNode = new ListNode(sum, subHead);
                cur->next = newNode;
                cur = cur->next;
            }
        }
        return dummy->next;
    }
};
```

### [2182\. 构造限制重复的字符串](https://leetcode.cn/problems/construct-string-with-repeat-limit/)


给你一个字符串 `s` 和一个整数 `repeatLimit` ，用 `s` 中的字符构造一个新字符串 `repeatLimitedString` ，使任何字母 **连续** 出现的次数都不超过 `repeatLimit` 次。你不必使用 `s` 中的全部字符。

返回 **字典序最大的**`repeatLimitedString` 。

如果在字符串 `a` 和 `b` 不同的第一个位置，字符串 `a` 中的字母在字母表中出现时间比字符串 `b` 对应的字母晚，则认为字符串 `a` 比字符串 `b` **字典序更大** 。如果字符串中前 `min(a.length, b.length)` 个字符都相同，那么较长的字符串字典序更大。

**示例 1：**

```
输入：s = "cczazcc", repeatLimit = 3
输出："zzcccac"
解释：使用 s 中的所有字符来构造 repeatLimitedString "zzcccac"。
字母 'a' 连续出现至多 1 次。
字母 'c' 连续出现至多 3 次。
字母 'z' 连续出现至多 2 次。
因此，没有字母连续出现超过 repeatLimit 次，字符串是一个有效的 repeatLimitedString 。
该字符串是字典序最大的 repeatLimitedString ，所以返回 "zzcccac" 。
注意，尽管 "zzcccca" 字典序更大，但字母 'c' 连续出现超过 3 次，所以它不是一个有效的 repeatLimitedString 。
```

**示例 2：**

```
输入：s = "aababab", repeatLimit = 2
输出："bbabaa"
解释：
使用 s 中的一些字符来构造 repeatLimitedString "bbabaa"。 
字母 'a' 连续出现至多 2 次。 
字母 'b' 连续出现至多 2 次。 
因此，没有字母连续出现超过 repeatLimit 次，字符串是一个有效的 repeatLimitedString 。 
该字符串是字典序最大的 repeatLimitedString ，所以返回 "bbabaa" 。 
注意，尽管 "bbabaaa" 字典序更大，但字母 'a' 连续出现超过 2 次，所以它不是一个有效的 repeatLimitedString 。
```

**提示：**

*   `1 <= repeatLimit <= s.length <= 10<sup>5</sup>`
*   `s` 由小写英文字母组成


#### Solution

给定一个字符串，用 s 中的字母拼接成一个字典序最大的字符串

此字符串需要满足每一个字母都不会连续出现大于 `repeatLimit` 次

思路：
- 每一次都放入最大的字符，当最大的字符的数量到达边界的时候
- 放入次大的一个字符
- 再回头考虑最大的字符，如果放完最大的字符了
- 那么最大的字符就更新为之前的次大的字符
- 循环执行
- 直到最小的一个字符连续出现等于 repeatLimit 次的时候，或者字符串 s 被用光的时候，程序结束
- 返回合并好的字符串 


``` go 
func repeatLimitedString(s string, repeatLimit int) string {
    freq := make([]int, 26)
    for i := 0; i < len(s); i++ {
        freq[s[i] & 31 - 1]++
    }
    ans := make([]byte, 0, len(s)) // ans 最长为 len(s)
    maxIndex := 25 
    for maxIndex >= 0 {
        if freq[maxIndex] > repeatLimit {
            // 如果当前字母的剩余频次比限制多
            freq[maxIndex] -= repeatLimit
            
            // 答案中放入限制频次的 对应字符
            for j := 0; j < repeatLimit; j++ {
                ans = append(ans, 'a' + byte(maxIndex))
            }
            
            var found bool = false
            
            // 放入次大的一个字母，放一个就溜
            for i := maxIndex - 1; i >= 0; i-- {
                if freq[i] > 0 {
                    ans = append(ans, 'a' + byte(i))
                    freq[i]--
                    found = true
                    break
                }
            }
            
            // 如果没有任何一个次大的元素可被放入，结束即可
            if found == false {
                break
            }
            
            // 这种情况下的 maxIndex 不减
        } else if freq[maxIndex] > 0 {
            // 当一个字母的频次 大于 0 小于限制的时候，全部扔到答案里
            for k := 0; k < freq[maxIndex]; k++ {
                ans = append(ans, 'a' + byte(maxIndex))
            }
            freq[maxIndex] = 0
            maxIndex--
        } else {
            maxIndex--
        }
    }
    
    return string(ans)
}
```

### [2183\. 统计可以被 K 整除的下标对数目](https://leetcode.cn/problems/count-array-pairs-divisible-by-k/)


给你一个下标从 **0** 开始、长度为 `n` 的整数数组 `nums` 和一个整数 `k` ，返回满足下述条件的下标对 `(i, j)` 的数目：

*   `0 <= i < j <= n - 1` 且
*   `nums[i] * nums[j]` 能被 `k` 整除。

**示例 1：**

```
输入：nums = [1,2,3,4,5], k = 2
输出：7
解释：
共有 7 对下标的对应积可以被 2 整除：
(0, 1)、(0, 3)、(1, 2)、(1, 3)、(1, 4)、(2, 3) 和 (3, 4)
它们的积分别是 2、4、6、8、10、12 和 20 。
其他下标对，例如 (0, 2) 和 (2, 4) 的乘积分别是 3 和 15 ，都无法被 2 整除。    
```

**示例 2：**

```
输入：nums = [1,2,3,4], k = 5
输出：0
解释：不存在对应积可以被 5 整除的下标对。
```

**提示：**

*   `1 <= nums.length <= 10<sup>5</sup>`
*   `1 <= nums[i], k <= 10<sup>5</sup>`


#### Solution

Language: ****

```
class Solution {
public:
    long long coutPairs(vector<int>& nums, int k) {
        
    }
};
```