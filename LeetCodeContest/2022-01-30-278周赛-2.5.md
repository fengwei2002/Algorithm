第三题超时，前两题写的太慢了，之后前面可以快一些空下时间来写第四题

## A [2154. 将找到的值乘以 2](https://leetcode-cn.com/problems/keep-multiplying-found-values-by-two/)

难度简单3

给你一个整数数组 nums ，另给你一个整数 original ，这是需要在 nums 中搜索的第一个数字。

接下来，你需要按下述步骤操作：

如果在 nums 中找到 original ，将 original 乘以 2 ，得到新 original（即，令 original = 2 * original）。
否则，停止这一过程。
只要能在数组中找到新 original ，就对新 original 继续 重复 这一过程。
返回 original 的 最终 值。



比赛的时候第一遍没有想清楚，直接找到一次乘以 2 了，但是每次都要从数组的起始位置开始查找，所以使用了双指针，但是应该使用哈希表写起来最简单




```go []
func findFinalValue(nums []int, original int) int {
    hash := make(map[int]bool, 0)
    for _, num := range nums {
        hash[num] = true
    }
    for hash[original] {
        original *= 2
    }
    return original
}
```
```c++ []
class Solution {
public:
    int findFinalValue(vector<int>& nums, int original) {
        for (int i = 0; i < nums.size(); i++) {
            for (int j = 0; j < nums.size(); j++) {
                if (nums[j] == original) {
                    original *= 2;
                }
            }
        }
        return original;
    }
};
```

优化写法：

要找的是 original 的 2 的幂次倍数，因此可以用一个二进制数字 mask 记录 nums 中含有哪些 original 的 2 的幂次倍数 

遍历完 nums 之后，我们可以模拟题目的过程，**从 mask 的最低位开始**，找出连续的 2 的幂次倍数

也就是从低位开始，找到连续 1 的个数

将 mask 取反之后，找最低位的 1，，其对应的二进制数即为我们可以达到的最大 22 的幂次倍数。

```go []
func findFinalValue(nums []int, original int) {
    mask := 0
    for _, num := range nums {
        if num % original == 0 { // 说明 num 是 original 的倍数
            k := num / original  // k 存储具体的倍数
            if k & (k - 1) == 0 {// 具体的倍数是 2 的幂次
                mask |= k        // 就将这一位存起来
            }
        } 
    }
    mask = ^mask // 取反后，找最低位的 1（lowbit = mask & -mask）
    return original * (mask & -mask)
}
```

二进制规则：

一个数字的减去一在二进制表示中就相当于从这个数字最右侧的一个一开始之后的所有位都取反

此时如果再把原来的整数和减去 1 之后的结果做与运算，从原来整数最右边那一位开始的所有位都会变为 0 （不相等的位与运算都是 0）

所以 `k & (k - 1) == 0` 就可以判断 k 是不是 2 幂运算的结果

mask 本来都是 0， `mask |= k`， 或的结果是有一个 1 结果就为 1 

两个数字做 |= 的操作，(存在一个 1， 计算的结果就为 1) ，就可以把这一位给存起来, 

现在得到一个 mask 存储形式类似于 1001111， 根据题意找出从低位开始数的连续 1 的结束位置即可

>  数据范围在 0 到 1k， 所以每次取出末位进行统计的话，也就差不多 10 次而已；
>
> for i := 0; i <= 10; i++ { if mask >> i & 1 {cnt++} else {break}}

正经找 1 解法：

将 mask 取反得到  0110000, 那么 ^mask 从左往右最低位的 1 的位置其实就是 mask 中从低位开始数连续 1 的结束位置

求一个数字二进制表示中的最低的 1 的位置可以用 lowbit 函数：

`int lowbit(int &a) { return a & -a; }`

根据计算机负数的特点，如果一个数字原码表示是 11001100, 他的负数表示形式是补码，也就是反码加一

假设反码为 00110011， 加一是 00110100 

二者按位相与得到 00000100 , 所以 `maks & -mask` 的结果就是二进制表示中最后一个 1 出现的位置

## B [2155. 分组得分最高的所有下标](https://leetcode-cn.com/problems/all-divisions-with-the-highest-score-of-a-binary-array/)

给你一个下标从 0 开始的二进制数组 nums ，数组长度为 n 。nums 可以按下标 i（ 0 <= i <= n ）拆分成两个数组（可能为空）：numsleft 和 numsright 。

numsleft 包含 nums 中从下标 0 到 i - 1 的所有元素（包括 0 和 i - 1 ），而 numsright 包含 nums 中从下标 i 到 n - 1 的所有元素（包括 i 和 n - 1 ）。
如果 i == 0 ，numsleft 为 空 ，而 numsright 将包含 nums 中的所有元素。
如果 i == n ，numsleft 将包含 nums 中的所有元素，而 numsright 为 空 。
下标 i 的 分组得分 为 numsleft 中 0 的个数和 numsright 中 1 的个数之 和 。

返回 分组得分 最高 的 所有不同下标 。你可以按 任意顺序 返回结果



这道题就是预处理一下每个下标的前缀和和后缀和，然后求一遍最大值即可

写前缀和后缀和调试完记得把 cout 删掉。。否则超时

``` cpp
class Solution {
public:
    vector<int> maxScoreIndices(vector<int>& nums) {
        vector<int> ans;
        
        int n = nums.size();
        // 统计每个点的前面有多少个 0 
        vector<int> zeroCount(nums.size() + 1, 0);
         for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == 0) {
                totalZero += 1;
            }
            zeroCount[i + 1] = totalZero;
        }
        zeroCount[0] = 0;
        // 统计每个点的后面有多少个 1
        vector<int> oneCount(nums.size() + 1, 0);
        int totalOne = 0;
        oneCount[0] = 0;
        for (int i = nums.size() - 1; i >= 0; i--) {
            if (nums[i] == 1) {
                totalOne += 1;
            }
            oneCount[i] = totalOne;
        }
        oneCount[0] = totalOne;
        nums.push_back(-1);
        for (int i = 0; i < n + 1; i++) {
            ans.push_back(zeroCount[i] + oneCount[i]);
        }
        sort(ans.begin(), ans.end(), [&](int a, int b) {
            return a > b;
        });
        
        // 计算 ans 中连续值的长度
        int i = 1;
        while (i > 0 && i < ans.size() && ans[i] == ans[i - 1]) {
            i++;
        }

        ans.erase(ans.begin() + i, ans.end());
        int x = ans[0];
        ans.resize(0);
        for (int i = 0; i < n + 1; i++) {
            if (zeroCount[i] + oneCount[i] == x) ans.push_back(i);
        }
        return ans;
    }
};

// 二进制数组 nums
// 长度为 n 
// nums 可以变为两个数组 numsleft numsright
// 具体的得分为 numsleft 中的 0 的个数和 numsright 中的 1 的个数 
// 返回最大得分的分组情况组成的数组
```

看下 0x3f 的题解，省去了 O(n) 的空间，简洁优美：

``` go
func maxScoreIndices(nums []int) []int {
    left, right := 0, 0
    for i := len(nums) - 1; i >= 0; i-- {
        right += nums[i]
    } // right 中存储整个数组中 1 的个数 
    
    maxSum := right
    ans := []int{0}
    
    for i, v := range nums {
        left += v ^ 1 // 一个数字和 1 进行异或，数字为 0 时结果为 1
        right -= v    // 更新此时的 1 的个数 
        
        if left + right > maxSum { // 如果出现了更大的数字
            maxSum = left + right  // 将最大值进行更新
            ans = []int{i + 1}	   // 数组清空，第一个值填入此时的分割点 i + 1
        } else if left + right == maxSum {
            ans = append(ans, i + 1) // ans 的后面放入 i + 1 
        }
    }
    return ans
}
```



## C [2156. 查找给定哈希值的子串](https://leetcode-cn.com/problems/find-substring-with-given-hash-value/)

给定整数 p 和 m ，一个长度为 k 且下标从 0 开始的字符串 s 的哈希值按照如下函数计算：

`hash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) mod m`.
其中 val(s[i]) 表示 s[i] 在字母表中的下标，从 val('a') = 1 到 val('z') = 26 。  

给你一个字符串 s 和整数 power，modulo，k 和 hashValue 。请你返回 s 中 第一个 长度为 k 的 子串 sub ，满足 hash(sub, power, modulo) == hashValue 。

测试数据保证一定 存在 至少一个这样的子串。

子串 定义为一个字符串中连续非空字符组成的序列。

``` cpp
示例 1：

输入：s = "leetcode", power = 7, modulo = 20, k = 2, hashValue = 0
输出："ee"
解释："ee" 的哈希值为 hash("ee", 7, 20) = (5 * 1 + 5 * 7) mod 20 = 40 mod 20 = 0 。
"ee" 是长度为 2 的第一个哈希值为 0 的子串，所以我们返回 "ee" 。
    
示例 2：

输入：s = "fbxzaad", power = 31, modulo = 100, k = 3, hashValue = 32
输出："fbx"
解释："fbx" 的哈希值为 hash("fbx", 31, 100) = (6 * 1 + 2 * 31 + 24 * 312) mod 100 = 23132 mod 100 = 32 。
"bxz" 的哈希值为 hash("bxz", 31, 100) = (2 * 1 + 24 * 31 + 26 * 312) mod 100 = 25732 mod 100 = 32 。
"fbx" 是长度为 3 的第一个哈希值为 32 的子串，所以我们返回 "fbx" 。
注意，"bxz" 的哈希值也为 32 ，但是它在字符串中比 "fbx" 更晚出现。
```

也就是给定一个字符串，给定一个字符串哈希值的计算方式，给定一个哈希值，判断给出的字符串的哈希值是不是和给出的哈希值相等



比赛写的时候想不到什么好的办法，我的写法就是纯模拟，每次全部重算

``` cpp
class Solution {
public:
    string subStrHash(string s, int pp, int mod, int k, int hashValue) {
        string ans = "";
        // cout << s.size() << endl;
        // O(n^2)
        if (s.size() != k) {
            for (int j = 0; j < s.size() - k; j++) {
                long long val = 0;
                int i = j;
                int dummyLength = 0;
                long long p  = 1;
                while (i < j + k) {
                    dummyLength++;
                    val = (val % mod + ((s[i] - 'a' + 1) % mod) * (p % mod)) % mod;
                    p = p % mod * pp % mod;
                    p = p % mod;
                    i++;
                }
                i--;
                if (dummyLength == k && val == hashValue) {
                    ans = s.substr(j, k);
                    return ans;
                }
            }
        } else {
            long long val = 0;
            int i = 0;
            long long p = 1;
            while (i < s.size()) {
                val = (val % mod + ((s[i] - 'a' + 1) % mod) * (p % mod)) % mod;
                p = p % mod * pp % mod;
                p = p % mod;
                i++;
            }
            if (val == hashValue) {
                ans = s;
                return ans;
            }
        }

        return ans;
    }
};
```

暴力通过数据 46/90

---

正确解法：

容易想到一个长度为k的滑动窗口。（滑动窗口的前一个计算出来的状态在之后可以继续使用，以后先考虑看看能不能继续使用）

由于相邻的两个子串具有高度重复性，可以考虑使用滑动窗口的办法求解

从前往后进行扫描的话：

`hashNext = (hashNow/power - s[old] + s[new] * power{k-1})`

由于使用除法过程中的取模运算，除法应该采用乘法逆元实现。除法不满足取余的恒等性。而乘法满足

(举个例子。**模10余4有很多种，24、54都是模10余4的，但是在除以6以后模10各不相同，分别为4和9** )

所以不想用除法取模，但是还想用这个得出的递推条件的话，就：

从后往前进行考虑：

`hashNext = (s[new] * p^0 + (hashNow - s[old] * power{k - 1}) * power)`

**只需要使用减法和乘法和取模运算就可以得到新的 hash 值**，**跳过了 除法取模求逆元的过程，同时利用了递推式**

``` cpp
class Solution {
public:
    string subStrHash(string s, int power, int mod, int k, int hashValue) {
        long long hash = 0;
        long long p = 1;
        int lastIndex = INT_MAX;
        for (int i = s.size() - k; i < s.size(); i++) {
            hash = (hash + val(s[i]) * p) % mod;
            p = p * power % mod;
        }
        if (hash == hashValue) lastIndex = s.size() - k;
        // 先计算一次最后一个滑动窗口是否满足条件

        long long pksub1 = 1;
        for (int i = 0; i < k - 1; i++) pksub1 = pksub1 * power % mod;
        // 预处理 p 的 k - 1 次方
        
        for (int i = s.size() - k - 1; i >= 0; i--) {
            int addPart = val(s[i]);
            int delPart = val(s[i + k]) * pksub1 % mod;
            hash = (hash - delPart + mod) % mod;
            hash = (hash * power) % mod;
            hash = (hash + addPart) % mod;

            if (hash == hashValue) lastIndex = i;
        }
        // 执行逆序滑动窗口，非暴力求值，非除法取模

        return s.substr(lastIndex, k);
    }

    int val(char c) {
        return c - 'a' + 1;
    }
};
```

学到了，[我的题解链接](https://leetcode-cn.com/problems/find-substring-with-given-hash-value/solution/dao-xu-hua-dong-chuang-kou-qing-xi-yi-do-l57z/)



## TODO 2157. 字符串分组