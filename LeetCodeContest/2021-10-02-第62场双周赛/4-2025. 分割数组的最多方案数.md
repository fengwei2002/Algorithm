### 解题思路
返回枢纽的数目，枢纽之前的元素和等于枢纽之后的数目

可以使用 k 改变 nums 中的一个数字，或者不改变，求所有可能的数目

``` cpp
// 遍历每一个数字 i， 如果 i 的值变为 k 
// 差值为 k - nums[i]
// 现在以 i 为分界点，小于 i 索引的位置 的 右侧区间减左侧区间的 差值 必定会 减少 k - nums[i]，
//                                                                    - (k - nums[i]) == ()nums[i] - k)
//           同样大于等于 i 索引的位置 的 右侧区间减左侧区间的 差值 必定会 增加 k - nums[i] 
// 差值为 k - nums[i] 和 差值为 -(k - num[i]) 的分组方式 统统可以被 k 替换
```

### 代码

```cpp

// https://github.com/fengwei2002/algorithm

class Solution {
  public:
    int waysToPartition(vector<int>& nums, int k) {
        typedef long long LL;
        int n = nums.size();
        vector<LL> prefix(n);

        prefix[0] = nums[0];
        LL ans = 0;
        for (int i = 1; i < n; ++i) prefix[i] = prefix[i - 1] + nums[i];
        
        unordered_map<LL, LL> left, right; // 开两个哈希表。保存以 i 为区分的左、右差值

        for (int i = 0; i < n - 1; i++) {
            LL cnt = prefix[n - 1] - 2 * prefix[i]; // 计算以 i 为区分的左、右差值, i 就是枢纽，nums[i] 在后半部分
            right[cnt]++;                           // 将以 i 为区分的 右侧区间减去左侧区间的差值，放入 right 中
            if (cnt == 0) ans++;                    // 差值等于 0 的话，答案就可以加一（不使用 k 修改数组）
        }

        for (int i = 0; i < n; ++i) {
            LL cnt = prefix[n - 1] - 2 * prefix[i]; // 再次计算 i 区分的左右差值
            ans = max(ans, left[nums[i] - k] + right[k - nums[i]]);
            right[cnt]--, left[cnt]++;
            // 同时，我们将右边的差值哈希表减少，将左边的差值哈希表增加（类似滑动窗口）
            // 右侧哈希表将 一种 cnt 方案去除， 左侧哈希表加上一种 cnt 方案 
        }
        return ans;
    }
};
```

[题解](https://leetcode-cn.com/problems/maximum-number-of-ways-to-partition-an-array/solution/lc2025-fengwei2002-qian-zhui-he-ha-xi-bi-f93m/)


再写一遍

``` cpp
class Solution {
  public:
    int waysToPartition(vector<int>& nums, int k) {
        typedef long long LL;
        int n = nums.size();
        vector<LL> prefix(n);

        prefix[0] = nums[0];
        LL ans = 0;
        for (int i = 1; i < n; ++i) prefix[i] = prefix[i - 1] + nums[i];
        
        unordered_map<LL, LL> left, right;

        for (int i = 0; i < n - 1; i++) {
            LL cnt = prefix[n - 1] - 2 * prefix[i]; 
            right[cnt]++;                           
            if (cnt == 0) ans++;    
        }

        for (int i = 0; i < n; ++i) {
            LL cnt = prefix[n - 1] - 2 * prefix[i];
            ans = max(ans, right[k - nums[i]], left[nums[i] - k]);
            right[cnt]--, left[cnt]++;
        }
        return ans;
    }
};
```