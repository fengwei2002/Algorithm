
## A: 打折购买糖果的最小开销

[原题链接](https://leetcode.cn/problems/minimum-cost-of-buying-candies-with-discount/)

### 题目描述

一家商店正在打折销售糖果。每购买 两个 糖果，商店会 免费 送一个糖果。

免费送的糖果唯一的限制是：它的价格需要小于等于购买的两个糖果价格的 较小值。

比方说，总共有 4 个糖果，价格分别为 1，2，3 和 4，一位顾客买了价格为 2 和 3 的糖果，那么他可以免费获得价格为 1 的糖果，但不能获得价格为 4 的糖果。
给你一个下标从 0 开始的整数数组 cost，其中 cost[i] 表示第 i 个糖果的价格，请你返回获得 所有 糖果的 最小 总开销。

### 思路

买二送一，求获得所有糖果的最小的总开销

那么也就是每次送的那一个糖果的值要尽可能的贵


### 代码


``` cpp
class Solution {
public:
    int minimumCost(vector<int>& cost) {
        int n = cost.size();
        sort(cost.begin(), cost.end());
        int ans = 0;
        if  (n < 2) {
            ans += cost[0];
            return ans;
        }
        
        for (int i = n - 1; i >= 0; i -= 3) {
            ans += cost[i];
            if (i - 1 >= 0) {
                ans += cost[i - 1];
            }
        }
        return ans;
    }
};

// 免费糖果的限制是： 小于等于 最小值
// 返回获得所有糖果的最小开销
```

---

## B: 统计隐藏数组数目 

[原题链接](https://leetcode.cn/problems/count-the-hidden-sequences/)

### 题目描述

给你一个下标从 0 开始且长度为 n 的整数数组 differences，它表示一个长度为 n + 1 的 隐藏 数组 相邻 元素之间的 差值。更正式的表述为：我们将隐藏数组记作 hidden，那么 `differences[i] = hidden[i + 1] - hidden[i]`。

同时给你两个整数 lower 和 upper，它们表示隐藏数组中所有数字的值都在 闭 区间 [lower, upper] 之间。

比方说，`differences = [1, -3, 4]，lower = 1，upper = 6`，那么隐藏数组是一个长度为 4 且所有值都在 1 和 6（包含两者）之间的数组。  
`[3, 4, 1, 5]` 和 `[4, 5, 2, 6]` 都是符合要求的隐藏数组。  
`[5, 6, 3, 7]` 不符合要求，因为它包含大于 6 的元素。  
`[1, 2, 3, 4]` 不符合要求，因为相邻元素的差值不符合给定数据。  
请你返回 符合 要求的隐藏数组的数目。如果没有符合要求的隐藏数组，请返回 0。  


### 样例


样例 1：
``` cpp 
输入：differences = [1,-3,4], lower = 1, upper = 6
输出：2
解释：符合要求的隐藏数组为：
- [3, 4, 1, 5]
- [4, 5, 2, 6]
所以返回 2。
```


样例 2：

``` cpp
输入：differences = [3,-4,5,1,-2], lower = -4, upper = 5
输出：4
解释：符合要求的隐藏数组为：
- [-3, 0, -4, 1, 2, 0]
- [-2, 1, -3, 2, 3, 1]
- [-1, 2, -2, 3, 4, 2]
- [0, 3, -1, 4, 5, 3]
所以返回 4。
```


### 思路

给定一个数组，每一个元素代表 hidden 数组的相邻元素的差值， hidden 所有元素都在 `[lower, upper]` 区间内，求可能存在的 hidden 数量

不会写，看题解：

---

思维题：

- 假设隐藏数组的第一个数字为 00，通过 differences，可以复原整个隐藏数组。
- 假设被复原的隐藏数组的最大值为 maxValue, 最小值为 minValue, 只需要关注最大值和最小值，整体增加或者减少隐藏数组，使之处于 lower 到 upper 区间即可
- 最终符合要求的数组的数量就是 `max(upper - lower + 1 - (maxValue - minValue)), 0`


### 代码


``` cpp
class Solution {
public:
    int numberOfArrays(vector<int>& differences, int lower, int upper) {
        const int n = differences.size();

        long long minValue = 0, maxValue = 0;
        long long s = 0;
        for (int i = 0; i < n; i++) {
            s += differences[i];
            minValue = min(minValue, s);
            maxValue = max(maxValue, s);
        }

        return max(upper - lower - (maxValue - minValue) + 1, 0ll);
    }
};
```



---

## [C: 价格范围内最高排名的 K 样物品](https://leetcode.cn/problems/k-highest-ranked-items-within-a-price-range/solution/lc5973-fengwei2002-by-kycu-quhs/)

[原题链接](https://leetcode.cn/problems/k-highest-ranked-items-within-a-price-range/)

### 题目描述

给你一个下标从 0 开始的二维整数数组 grid，它的大小为 m x n，表示一个商店中物品的分布图。数组中的整数含义为：

0 表示无法穿越的一堵墙。
1 表示可以自由通过的一个空格子。
所有其他正整数表示该格子内的一样物品的价格。你可以自由经过这些格子。
从一个格子走到上下左右相邻格子花费 1 步。

同时给你一个整数数组 pricing 和 start，其中 pricing = [low, high] 且 start = [row, col]，表示你开始位置为 (row, col)，同时你只对物品价格在 闭区间 [low, high] 之内的物品感兴趣。同时给你一个整数 k。

你想知道给定范围 内 且 排名最高 的 k 件物品的 位置。排名按照优先级从高到低的以下规则制定：

距离：定义为从 start 到一件物品的最短路径需要的步数（较近 距离的排名更高）。
价格：较低 价格的物品有更高优先级，但只考虑在给定范围之内的价格。
行坐标：较小 行坐标的有更高优先级。
列坐标：较小 列坐标的有更高优先级。
请你返回给定价格内排名最高的 k 件物品的坐标，将它们按照排名排序后返回。如果给定价格内少于 k 件物品，那么请将它们的坐标 全部 返回。


### 样例


样例 1：
![20220123194938-2022-01-23-19-49-43](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/images/20220123194938-2022-01-23-19-49-43.png)
``` cpp 
输入：grid = [[1,2,0,1],[1,3,0,1],[0,2,5,1]], pricing = [2,5], start = [0,0], k = 3
输出：[[0,1],[1,1],[2,1]]
解释：起点为 (0,0)。
价格范围为 [2,5]，我们可以选择的物品坐标为 (0,1)，(1,1)，(2,1) 和 (2,2)。
这些物品的排名为：
- (0,1) 距离为 1
- (1,1) 距离为 2
- (2,1) 距离为 3
- (2,2) 距离为 4
所以，给定价格范围内排名最高的 3 件物品的坐标为 (0,1)，(1,1) 和 (2,1)。
```


样例 2：
![20220123194956-2022-01-23-19-49-57](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/images/20220123194956-2022-01-23-19-49-57.png)
``` cpp
输入：grid = [[1,2,0,1],[1,3,3,1],[0,2,5,1]], pricing = [2,3], start = [2,3], k = 2
输出：[[2,1],[1,2]]
解释：起点为 (2,3) 。
价格范围为 [2,3]，我们可以选择的物品坐标为 (0,1)，(1,1)，(1,2) 和 (2,1)。
这些物品的排名为： 
- (2,1) 距离为 2，价格为 2
- (1,2) 距离为 2，价格为 3
- (1,1) 距离为 3
- (0,1) 距离为 4
所以，给定价格范围内排名最高的 2 件物品的坐标为 (2,1) 和 (1,2)。
```
![20220123195013-2022-01-23-19-50-14](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/images/20220123195013-2022-01-23-19-50-14.png)


``` cpp 
输入：grid = [[1,1,1],[0,0,1],[2,3,4]], pricing = [2,3], start = [0,0], k = 3
输出：[[2,1],[2,0]]
解释：起点为 (0,0)。
价格范围为 [2,3]，我们可以选择的物品坐标为 (2,0) 和 (2,1)。
这些物品的排名为：
- (2,1) 距离为 5
- (2,0) 距离为 6
所以，给定价格范围内排名最高的 2 件物品的坐标为 (2,1) 和 (2,0)。
注意，k = 3 但给定价格范围内只有 2 件物品。
```

### 思路

算法： BFS

比赛的时候找到了所有可能满足要求的下标，但是不会对这些数据根据题目已知的 4 个条件进行排序，排序后选取前 k 个元素即可

比赛时的想法 ：
``` cpp
对于每一件在价格区间内的物品进行溯源距离求值
用一个二维矩阵进行存储 
    把距离相等的元素读出来，
        把距离相等的元素中的值相等的元素读出来
            把相等的元素中行(i) 更加小的读取出来
                最后再看第几列
```
也就是 sort 里套 sort 里套 sort 里套 sort 。。。。


### 代码


``` cpp
class Solution {
public:
    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {
        int n = grid.size();
        int m = grid[0].size();
        
        vector<vector<int>> dist(n, vector<int>(m, 0));
        vector<vector<bool>> st(n, vector<bool>(m, false));
        
        queue<pair<int, int>> q;
        q.push({start[0], start[1]});
        st[start[0]][start[1]] = true;
        
        int dx[4] = {-1, 0, 1, 0}; // 上右下左
        int dy[4] = {0, 1, 0, -1};
        
        while (q.size()) {
            auto t = q.front();
            q.pop();
            
            for (int i = 0; i < 4; i++) {
                int a = t.first + dx[i], b = t.second + dy[i];
                if (a >= 0 && a < n && b >= 0 && b < m && grid[a][b] != 0 && st[a][b] == false) { // 如果在地图内
                    if (grid[a][b] == 1 || grid[a][b] < pricing[0] || grid[a][b] > pricing[1]) {
                        dist[a][b] = dist[t.first][t.second] + 1;
                        q.push({a, b});
                        st[a][b] = true;
                    } else {
                        // 新的点是一个价格的点
                        dist[a][b] = dist[t.first][t.second] + 1;
                        q.push({a, b});
                        st[a][b] = true;
                    }
                }
            }
        }
        

        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (st[i][j] == true && grid[i][j] >= pricing[0] && grid[i][j] <= pricing[1]) {
                    dist[i][j] = dist[i][j];
                } else {
                    dist[i][j] = -1;
                }
            }
        }

        
        vector<vector<int>> temp;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (dist[i][j] != -1) {
                    temp.push_back({i, j});
                }
            }
        }
        
        // dist[i][j] 存储具体的距离
        // grid[i][j] 存储具体的值
        // temp[pair<int, int>] 存储所有可以拿走的物品的具体下标
        
        // 根据 dist[i][j] 对 temp 数组进行排序

        /*如何根据四种不同的要求对 temp 数组进行排序*/
        /*----------------------------------*/
        sort(temp.begin(), temp.end(), [&](vector<int> a, vector<int> b) {
            int ax = a[0], ay = a[1], bx = b[0], by = b[1];
            return dist[ax][ay] < dist[bx][by];
        });
        /*----------------------------------*/
        
        
        vector<vector<int>> ans;
        for (int i = 0; i < k; i++) {
            ans.push_back({temp[i][0], temp[i][1]});
        }
        return ans;
    }
};
```


---



``` cpp
sort(ans.begin(), ans.end(), [&](const vector<int>& p, const vector<int>& q) {
    int px = p[0], py = p[1], qx = q[0], qy = q[1];
    if (dist[px][py] < dist[qx][py]) {
        return dist[px][py] < dist[qx][qy];
    }

    if (grid[px][py] < grid[qx][qy]) {
        return grid[px][py] < grid[qx][qy];
    }

    if (px != qx) {
        return px < qx;
    }

    return py < qy;
});
// sort 中的匿名函数的参数都要加上 const 前缀，更加合理
// sort 中的匿名函数可以不止一个返回值，在第一个 return 处没有返回的话，就考虑第二个条件
// 所以考虑第二个条件的时候，条件一必定满足
// 合理
```

所以完善一下比赛时候的代码：


``` cpp 
class Solution {
public:
    vector<vector<int>> highestRankedKItems(vector<vector<int>>& grid, vector<int>& pricing, vector<int>& start, int k) {
        int n = grid.size();
        int m = grid[0].size();
        
        vector<vector<int>> dist(n, vector<int>(m, 0));
        vector<vector<bool>> st(n, vector<bool>(m, false));
        
        queue<pair<int, int>> q;
        q.push({start[0], start[1]});
        st[start[0]][start[1]] = true;
        
        int dx[4] = {-1, 0, 1, 0}; // 上右下左
        int dy[4] = {0, 1, 0, -1};
        
        while (q.size()) {
            auto t = q.front();
            q.pop();
            
            for (int i = 0; i < 4; i++) {
                int a = t.first + dx[i], b = t.second + dy[i];
                if (a >= 0 && a < n && b >= 0 && b < m && grid[a][b] != 0 && st[a][b] == false) { 
                    // 如果在地图内并且没有被遍历过
                    dist[a][b] = dist[t.first][t.second] + 1;
                    q.push({a, b});
                    st[a][b] = true;
                }
            }
        }
        
        vector<vector<int>> ans;
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                // 如果被遍历过并且在价格区间内，存入 ans 中
                if (st[i][j] == true && grid[i][j] >= pricing[0] && grid[i][j] <= pricing[1]) {
                    ans.push_back({i, j});
                }
            }
        }

        sort(ans.begin(), ans.end(), [&](const vector<int>& a, const vector<int>& b) {
            int ax = a[0], ay = a[1], bx = b[0], by = b[1];

            if (dist[ax][ay] != dist[bx][by]) {
                return dist[ax][ay] < dist[bx][by];
            }

            if (grid[ax][ay] != grid[bx][by]) {
                return grid[ax][ay] < grid[bx][by];
            }

            if (ax != bx) {
                return ax < bx;
            }

            return ay < by;
        });

        if (ans.size() <= k) {
            return ans;
        } 
        ans.resize(k);
        return ans;
    }
};
```

## D: 分隔长廊的方案数

[原题链接](https://leetcode.cn/problems/number-of-ways-to-divide-a-long-corridor/)

### 题目描述

在一个图书馆的长廊里，有一些座位和装饰植物排成一列。给你一个下标从 0 开始，长度为 n 的字符串 corridor，它包含字母 'S' 和 'P'，其中每个 'S' 表示一个座位，每个 'P' 表示一株植物。

在下标 0 的左边和下标 n - 1 的右边 已经 分别各放了一个屏风。你还需要额外放置一些屏风。每一个位置 i - 1 和 i 之间（1 <= i <= n - 1），至多能放一个屏风。

请你将走廊用屏风划分为若干段，且每一段内都 恰好有两个座位，而每一段内植物的数目没有要求。可能有多种划分方案，如果两个方案中有任何一个屏风的位置不同，那么它们被视为 不同 方案。

请你返回划分走廊的方案数。由于答案可能很大，请你返回它对 10^9 + 7 取余 的结果。如果没有任何方案，请返回 0。


### 样例


样例 1：
![20220123221158-2022-01-23-22-12-01](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/images/20220123221158-2022-01-23-22-12-01.png)
``` cpp 
输入：corridor = "SSPPSPS"
输出：3
解释：总共有 3 种不同分隔走廊的方案。
上图中黑色的竖线表示已经放置好的屏风。
上图每种方案中，每一段都恰好有 两个 座位。
```


样例 2：
![20220123221251-2022-01-23-22-12-52](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/images/20220123221251-2022-01-23-22-12-52.png)
``` cpp
输入：corridor = "PPSPSP"
输出：1
解释：只有 1 种分隔走廊的方案，就是不放置任何屏风。
放置任何的屏风都会导致有一段无法恰好有 2 个座位。
```


### 思路

毫无思路

---

看题解：(乘法原理（高中数学老师教过。。）)

- 将每两个座位 `及其中间的` 植物看做一组，则需要在组与组之间放置一个屏风。
- 两组之间放置屏风的方案数为后一组开始的位置减去前一组结束的位置。特别地，第一组之前和最后一组之后不可以放置屏风。
- 以上为分步操作，所以将所有方案数乘起来就是答案。


### 代码


``` cpp
        // 给定一个长度为 n 的字符串 S 代表座位， P 代表一个植物
        // 开始和结尾处放置了两个屏风
        // 划分字符串，使得每一段都恰好存在两个 S 
        // 请你返回划分走廊的方案数对 1e9 + 7 取余 的结果
class Solution {
public:
    int numberOfWays(string corridor) {
        const int MOD = 1e9 + 7;
        const int n = corridor.size();

        vector<int> pos;
        for (int i = 0; i < n; i++) {
            if (corridor[i] == 'S') {
                pos.push_back(i);
            }
        }

        int cnt = pos.size();
        if (cnt == 0 || cnt & 1) {
            return 0;
        }
        if (cnt == 2) {
            return 1;
        }
        long long ans = 1;
        for (int i = 2; i < pos.size(); i += 2) {
            ans = (ans * (pos[i] - pos[i - 1])) % MOD;
        }
        return ans;
    }
};
```