
## A: name

原题链接

### 题目描述

题目描述  
给定一个正整数数组 arr，请你找出一个长度为 m 且在数组中至少重复 k 次的模式。

模式 是由一个或多个值组成的子数组（连续的子序列），连续 重复多次但不重叠。模式由其长度和重复次数定义。

如果数组中存在至少重复 k 次且长度为 m 的模式，则返回 true，否则返回 false。

### 样例


样例 1：
``` cpp 
输入：arr = [1,2,4,4,4,4], m = 1, k = 3
输出：true
解释：模式 (4) 的长度为 1，且连续重复 4 次。
注意，模式可以重复 k 次或更多次，但不能少于 k 次。
```


样例 2：

``` cpp
输入：arr = [1,2,1,2,1,1,1,3], m = 2, k = 2
输出：true
解释：模式 (1,2) 长度为 2 ，且连续重复 2 次。
另一个符合题意的模式是 (2,1) ，同样重复 2 次。

输入：arr = [1,2,1,2,1,3], m = 2, k = 3
输出：false
解释：模式 (1,2) 长度为 2 ，但是只连续重复 2 次。
不存在长度为 2 且至少重复 3 次的模式。
```


### 思路

对于每一个位置，如果 arr[i] 等于 arr[i + m], 则计数器加一， 否则计数器清 0


### 代码


``` cpp
class Solution {
public:
    bool containsPattern(vector<int>& arr, int m, int k) {
        // 只需要考虑 m 长度的子序列
        if (m * k > arr.size()) return false;
        int totalLength = m * k;
        for (int i = 0; i + totalLength - 1 < arr.size(); i++) {
            int endIndex = i + totalLength;
            
            // 判断 i 到 j 是否是由一个子序列重复形成的
            
            // 将第一个成段的部分放入队列中
            int firstWordIndex = i + m;
            queue<int> q;
            for (int j = i; j < firstWordIndex; j++) {
                q.push(arr[j]);
            }
            
            // 考察每个 m 是否是由队列中的元素重复组成的
            int count = 0;
            for (int j = i; j < endIndex; j += m) {
                auto copyq = q;
                int k = j;
                while (k < arr.size() && arr[k] == copyq.front()) {
                    copyq.pop();
                    k++;
                }
                if (copyq.size() == 0) {
                    count++;
                    copyq = q;
                } else {
                    break;
                }
            }
            if (count >= k) {
                return true;
            }
        }
        
        return false;
    }
};


// 给定 arr 找出一个长度为 m 且在数组中至少重复 k 次的模式。
// 长度为 m 连续的子序列，是否出现大于等于 k 次
// 出现过返回 true， 不出现返回 false
```

C++ 整洁的写法：


``` cpp 
class Solution {
public:
    bool containsPattern(vector<int>& arr, int m, int k) {
        int n = arr.size();
        for (int i = 0; i + m * k <= n; i ++ ) {
            bool flag = true;
            for (int j = i; j < i + m * k; j ++ )
                if (arr[j] != arr[i + (j - i) % m]) {
                    flag = false;
                    break;
                }
            if (flag) return true;
        }
        return false;
    }
};
```

GO:

``` go 
func containsPattern(arr []int, m int, k int) bool {
    n := len(arr)
    counter := 0

    for i := 0; i+m < n; i++ {
        if arr[i] == arr[i+m] {
            counter++
        } else {
            counter = 0
        }
        if counter == m*(k-1) {
            return true
        }
    }

    return false
}
```

### 反思

写双指针的 while 的时候，加上判断条件最佳，避免不必要的边界问题

---

## B: Maximum Length of Subarray With Positive Product

[原题链接](https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product/)

### 题目描述

给定一个整数数组 nums，请你求出乘积为正数的最长子数组的长度。

一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。

请你返回乘积为正数的最长子数组长度。

### 样例


样例 1：
``` cpp 
输入：nums = [1,-2,-3,4]
输出：4
解释：数组本身乘积就是正数，值为 24。

输入：nums = [0,1,-2,-3,-4]
输出：3
解释：最长乘积为正数的子数组为 [1,-2,-3] ，乘积为 6 。
注意，我们不能把 0 也包括到子数组中，因为这样乘积为 0 ，不是正数。

输入：nums = [-1,-2,-3,0,1]
输出：2
解释：乘积为正数的最长子数组是 [-1,-2] 或者 [-2,-3]。
```


### 思路



### 代码


``` cpp

```



``` golang
func getMaxLen(nums []int) int {
    const UNDEFINED = -1

    firstNegative := UNDEFINED
    lastZero := -1
    isNegative := false

    ans := 0
    for i, v := range nums {
        if v == 0 {
            lastZero = i
            isNegative = false
            lastNegative = UNDEFINED
        } else if v < 0 {
            isNegative = !isNegative
            if lastNegative == UNDEFINED {
                lastNegative = i
            }
        }

        if isNegative {
            ans = max(ans, i - lastNegative)
        } else {
            ans = max(ans, i - lastZero)
        }
    }

    return ans
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}
```
### 反思

DP 没有 D 出来 leetcode 152 

---

## C: 使陆地分离的最少天数

[原题链接](https://leetcode-cn.com/problems/minimum-number-of-days-to-disconnect-island/)

### 题目描述


给你一个由若干 0 和 1 组成的二维网格 grid ，其中 0 表示水，而 1 表示陆地。岛屿由水平方向或竖直方向上相邻的 1 （陆地）连接形成。

如果 恰好只有一座岛屿 ，则认为陆地是 连通的 ；否则，陆地就是 分离的 。

一天内，可以将任何单个陆地单元（1）更改为水单元（0）。

返回使陆地分离的最少天数。

### 样例


样例 1：
![20220124181356-2022-01-24-18-13-58](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/images/20220124181356-2022-01-24-18-13-58.png)
``` cpp 

```


样例 2：

``` cpp

```


### 思路

最少去掉多少个点使得无向图不连通

有一个通用的做法：acwing 381



### 代码


``` cpp

```


### 反思


---

## D: name

原题链接

### 题目描述



### 样例


样例 1：
``` cpp 

```


样例 2：

``` cpp

```


### 思路



### 代码


``` cpp

```


### 反思

