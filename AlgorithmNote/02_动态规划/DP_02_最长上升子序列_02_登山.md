## 登山

五一到了，ACM 队组织大家去登山观光，队员们发现山上一共有 N 个景点，并且决定按照顺序来浏览这些景点，即每次所浏览景点的编号都要大于前一个浏览景点的编号。  

同时队员们还有另一个登山习惯，就是不连续浏览海拔相同的两个景点，并且一旦开始下山，就不再向上走了。    
队员们希望在满足上面条件的同时，尽可能多的浏览景点，你能帮他们找出最多可能浏览的景点数么？

### 输入格式  

第一行包含整数 N，表示景点数量。 
第二行包含 N 个整数，表示每个景点的海拔。   

### 输出格式

输出一个整数，表示最多能浏览的景点数。   
数据范围  
2≤N ≤1000   

### 输入样例：
8  
186 186 150 200 160 130 197 220  

### 输出样例：

4  
解释: 186 200 160 130 

## DP 分析

折线最长子序列问题

## AC 代码

``` cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;
int n;
int h[N], l[N], r[N];

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) cin >> h[i];
    for (int i = 0; i < n; i++) {
        l[i] = 1;
        for (int j = 0; j < i; j++) {
            if (h[i] > h[j]) {
                l[i] = max(l[i], l[j] + 1);
            }
        }
    }
    for (int i = n - 1; i >= 0; i--) {
        r[i] = 1;
        for (int j = n - 1; j > i; j--) {
            if (h[i] > h[j]) {
                r[i] = max(r[i], r[j] + 1);
            }
        }
    }
    int ans = 0;
    for (int i = 0; i < n; i++) ans = max(ans, l[i] + r[i] - 1);
    // 去除多计算一次的顶点
    cout << ans << endl;
    return 0;
}
```