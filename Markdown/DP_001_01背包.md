`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);`
`dp[j] = max(dp[j], dp[j - value[i]] + weight[i]);`


[模板题链接](https://www.acwing.com/problem/content/2/) 

![01背包题面png](https://cdn.acwing.com/media/article/image/2021/08/10/101476_4625b7eaf9-01背包题面.png) 

![01背包DP分析.png](https://cdn.acwing.com/media/article/image/2021/08/11/101476_9478d007fa-01背包DP分析.png) 

<!-- 
![20210811112500-2021-08-11](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/images/20210811112500-2021-08-11.png) -->

``` cpp
#include <algorithm>
#include <cstring>
#include <iostream>

using namespace std;

const int N = 1010;

int n, m;
int f[N][N];
int v[N], w[N];

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    for (int i = 1; i <= n; i++){
        for (int j = 0; j <= m; j++) {
            f[i][j] = f[i - 1][j];
            if (j >= v[i]) {
                f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
            }
        }
    }
    int res = 0;
    for (int i = 0; i <= m; i++) res = max(res, f[n][i]);
    return 0;
}
```

## 如何转换为一维数组：

f[i] 只用到了 f[i - 1] 这一层，所以可以用滚动数组来做

**一:去掉一维之后 `f[j] = f[j];`**

``` cpp 
    for (int i = 1; i <= n; i++){
        for (int j = 0; j <= m; j++) {
            f[j] = f[j] //f[i][j] = f[i - 1][j];
            if (j >= v[i]) {
                f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
            }
        }
    }
```

**二：j 小于 `v[i]` 的时候，数组直接滑过去，所以 j 等于 0 到 `v[i] - 1` 是没有意义的, 所以就可以从 v[i] 开始循环，并且判断条件也可以删掉了**

``` cpp 
    for (int i = 1; i <= n; i++){
        // for (int j = 0; j <= m; j++) {
        //     f[j] = f[j] //f[i][j] = f[i - 1][j];
        //     if (j >= v[i]) {
        //         f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
        //     }
        // }
        for (int j = v[i]; j <= m; j++) {
            f[i][j] = max(f[i][j],f[i - 1][j - v[i]] + w[i]]);
        } 
    }
```

三：把状态计算也用一维数组表示出来

``` cpp 
for (int i = 1; i <= n; i++){
    for (int j = v[i]; j <= m; j++) {
        f[j] = max(f[j],f[j - v[i]] + w[i]]);
    } 
}
```

直接删掉之后并不和之前的等价， 因为从小到大进行遍历： `j - v[i]` 严格小于 j ， 所以 `f[j - v[i]]` 会在 f[i] 之前被计算，所以现在的 `f[j - v[i]] + w[i]])` 代表 `f[i][j - v[i]] + w[i]])` 而不是 `f[i - 1][j - v[i]] + w[i]])`

将循环顺序变为从大到小之后，现在的 `f[j - v[i]] + w[i]])` 还没有被更新过，所以他代表的就是 `f[i - 1][j - v[i]] + w[i]])`，等价于之前的状态转移方程

``` cpp 
for (int i = 1; i <= n; i++){
    for (int j = m; j >= v[i]; j--) {
        f[j] = max(f[j],f[j - v[i]] + w[i]]);
    } 
}
```

AC 代码：

``` cpp 
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n, m;
int v[N], w[N];
int f[N];

int main() {
    cin >> n >> m;

    for (int i = 1; i <= n; i ++ ) cin >> v[i] >> w[i];

    for (int i = 1; i <= n; i ++ )
        for (int j = m; j >= v[i]; j -- )
            f[j] = max(f[j], f[j - v[i]] + w[i]);

    cout << f[m] << endl;

    return 0;
}
```