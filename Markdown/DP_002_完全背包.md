## 理解完全背包

![完全背包题面.png](https://cdn.acwing.com/media/article/image/2021/08/11/101476_25f3a473fa-完全背包题面.png) 

## 完全背包 DP 分析

还是画一个图：

![完全背包DP分析.png](https://cdn.acwing.com/media/article/image/2021/08/11/101476_e43fbe84fa-完全背包DP分析.png) 

分析完成之后写一下：

``` cpp
#include <algorithm>
#include <iostream>

using namespace std;

const int N = 1010;

int n, m;
int v[N], w[N];
int f[N][N];

int main() {
    cin >> n >> m;
    for (int i = 0; i <= n; i++)
        cin >> v[i] >> w[i];
    
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= m; j++) {
            for (int k = 0; k * v[i] <= j; k++) { // 枚举 k 种情况
                f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + k * w[i]);
            }
        }
    }
    cout << f[n][m] << endl;
}
```

## 优化

观察：

![完全背包一维数组转换01.png](https://cdn.acwing.com/media/article/image/2021/08/11/101476_84209426fa-完全背包一维数组转换01.png) 

所以状态表示可以优化为： `f[i][j] = max (f[i - 1][j], f[i][j - v[i]] + w[i])`  

这样的话就优化掉了 k 这一个维度

``` cpp
#include <algorithm>
#include <iostream>

using namespace std;

const int N = 1010;

int n, m;
int v[N], w[N];
int f[N][N];

int main() {
    cin >> n >> m;
    for (int i = 0; i <= n; i++)
        cin >> v[i] >> w[i];
    
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= m; j++) {
            f[i][j] = f[i - 1][j];
            if (j >= v[i]) 
                f[i][j] = max(f[i][j], f[i - v[i]] + w[i]);
        }
    }
    cout << f[n][m] << endl;
}
```

## 再优化

对比 01 背包的状态计算：

01 背包为：`f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);`    
完全背包为：`f[i][j] = max(f[i - 1][j], f[i][j - v[i] + w[i])`

所以可以优化为 01 背包类似的一维写法（相比于 01 背包不逆序遍历即可）


``` cpp
#include <algorithm>
#include <iostream>

using namespace std;

const int N = 1010;

int n, m;
int v[N], w[N];
int f[N][N];

int main() {
    cin >> n >> m;
    for (int i = 0; i <= n; i++)
        cin >> v[i] >> w[i];
    
    for (int i = 1; i <= n; i++) {
        for (int j = v[i]; j <= m; j++) {
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
    }

    cout << f[n][m] << endl;
}
```

最后发现完全背包相比于 01 背包只是 for 循环的前后顺序不一样

