## 理解多重背包

![多重背包题面。png](https://cdn.acwing.com/media/article/image/2021/08/11/101476_a4c2b1f3fa-多重背包题面.png) 

## 多重背包 DP 分析

![多重背包 DP 分析.png](https://cdn.acwing.com/media/article/image/2021/08/11/101476_aa17c55cfa-多重背包DP-分析.png) 

## 多重背包暴力解法：

很简单，相当于在完全背包暴力解法上添加 `k <= s[i]` 这个条件

``` cpp 
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

int n, m;
int v[N], w[N], s[N];
int f[N][N];

int main(){
    cin >> n >> m;

    for (int i = 1; i <= n; i ++ ) 
        cin >> v[i] >> w[i] >> s[i];

    for (int i = 1; i <= n; i ++ )
        for (int j = 0; j <= m; j ++ )
            for (int k = 0; k <= s[i] && k * v[i] <= j; k ++ )
                f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);

    cout << f[n][m] << endl;
    return 0;
}
```

## 多重背包优化

`f[i, j] = max( f[i-1, j] , f[i-1, j-v]+w , f[i-1, j-2v]+2w ……  f[i-1, j-sv] + sw )`
观察  
`f[i, j-v] = max( f[i-1][j-v] , f[i-1, j-2v]+w ,  …… f[i-1, j-sv]+(s-1)w) , f[i-1, j-(s+1)v]+sw )`  

多了一项 `f[i-1, j-(s+1)v]+sw`， 所以不可以进行直接优化

### 二进制优化方式

当数据范围变大时

![20210811175151-2021-08-11-17-51-53](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/images/20210811175151-2021-08-11-17-51-53.png)

考虑对数据进行分组：

`0,1,2......,1023;` 共 1024 个数字
`1,2,4,8......512;` 共十个数字

把若干个第 i 个物品打包之后进行考虑，第一组是代表只有一个第 i 个物品，第二组代表只有两个第 i 个物品，依此类推，每组最多选择一次，就可以用这十组，拼凑出 0-1023 的所有数字

所以就相当于用十个物品选择与否来拼凑出第 i 个物品的所有方案

举例：

> s = 200 
> 分组： 1,2,4,8,16,32,64,73 [73 = 200 - 127(128-1)]
> 所以对二进制分组补上 73 就可以凑出 0 到 200 的所有数字了

设加上的数字为 C，那么 `C < 2^(k+1)` 成立，所以 `[0, 2^(k+1) -1]` 和 `[c, s]` 之间不存在缝隙，可以全部覆盖目标区间

**S 个 i 物品， 可以拆分为 logs 个，所有新出来的物品在做一遍 01背包即可！**  
进过分组之后，时间复杂度从 O(NVS) 优化到 O(NVlog_s)


``` cpp 
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 12010, M = 2010;

int n, m;
int v[N], w[N];
int f[M];

int main() {
    cin >> n >> m;

    int cnt = 0;
    for (int i = 1; i <= n; i ++ ) {
        int a, b, s; // 读入体积价值和个数
        cin >> a >> b >> s;
        int k = 1;
        while (k <= s) { // 把 k 个物品打包到一起
            cnt++;
            v[cnt] = a * k;
            w[cnt] = b * k;
            s -= k;
            k *= 2;
        }
        if (s > 0) { // 把最后的数字补上 C
            cnt++;
            v[cnt] = a * s;
            w[cnt] = b * s;
        }
    }

    n = cnt;

    // 默写 01 背包
    for (int i = 1; i <= n; i ++ )
        for (int j = m; j >= v[i]; j -- )
            f[j] = max(f[j], f[j - v[i]] + w[i]);

    cout << f[m] << endl;

    return 0;
}
```
