## 题面

![最长上升子序列题面02.png](https://cdn.acwing.com/media/article/image/2021/08/13/101476_303a8efefc-最长上升子序列题面02.png) 

## 优化方法

优化解法归类为贪心（每一步都是当前情况下的最优解，得到的就是最优解）

把**所有长度不同的递增最长子序列** 的 **结尾的最小值**存到一个数组(`q[]`)里面去，那么  
这个数组必然是递增的一个数组

- 考虑 `a[i]` 的最长上升子序列的长度：  
 - 在上面构建的数组中，找到一个最大的，小于 `a[i]` 的数 `q[j]`，然后将 `q[j + 1]` 置为 `a[i]`
    因为 `a[i] <= q[j + 1]`
    对于如何快速找到一个满足具体条件的值，用模板即可
    用二分查找, 找到**小于 a[i] 的最大值**，  

## AC 代码

``` cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n;
int a[N];
int q[N];

int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; i++) scanf("%d", &a[i]);

    int len = 0;
    for (int i = 0; i < n; i++) {
        int l = 0, r = len;
        while (l < r) {
            int mid = l + r + 1 >> 1;
            if (q[mid] < a[i]) l = mid;
            else r = mid - 1;
        }
        len = max(len, r + 1); // 更新一下，最长子序列的长度
        q[r + 1] = a[i]; // 更新对应长度结尾的最小值
    }

    printf("%d\n", len);

    return 0;
}
```

