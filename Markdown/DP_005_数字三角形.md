## 数字三角形 题面

![数字三角形题面.png](https://cdn.acwing.com/media/article/image/2021/08/12/101476_913c85adfb-数字三角形题面.png) 

## 数字三角形 DP 分析步骤

![数字三角形DP分析.png](https://cdn.acwing.com/media/article/image/2021/08/12/101476_97dbbc36fb-数字三角形DP分析.png) 

## AC 代码

``` cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 510, INF = 1e9;

int n;
int a[N][N];
int f[N][N]; // 代表从顶点到 ij 坐标的最大路径数值

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            cin >> a[i][j];
        }
    }

    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= i + 1; j++) {
            f[i][j] = -INF; 
            // 这里要多初始化一项，由于求最大值，所以初始为最小值
        }
    }

    f[1][1] = a[1][1];
    // 初始化目标数组的第一项，然后从 2 开始
    for (int i = 2; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            f[i][j] = f[i - 1][j - 1] + a[i][j];
            f[i][j] = max(f[i][j], f[i - 1][j] + a[i][j]);
        }
    }

    int ans = -INF;
    for (int i = 1; i <= n; i++) ans = max(ans, f[n][i]); 
    // 遍历最后一层，找出从第一层到最后一层的最大路径值
    cout << ans << endl;
    return 0;
}
```