[题解](https://leetcode-cn.com/problems/longest-nice-substring/solution/lc1763-fengwei2002-by-kycu-rvul/)

## 暴力的遍历所有子串

然后哈希表统计每个字符串中出现的字符，但是因为全是简单的字符，所以用两个数组来存也可以，一个存大写字母是否出现，一个存小写字母是否出现

当然简单的用 set 进行统计也可以

``` cpp
class Solution {
public:
    string longestNiceSubstring(string s) {
        string ans = "";
        for (int i = 0; i < s.size(); i++) {
            for (int j = 0; j < i; j++) {
                string test = s.substr(j, i - j + 1);
                unordered_set<char> S;
                for (auto& c : test) {
                    S.insert(c);
                }
                int count = 0;
                for (auto& c : test) {
                    int lo = S.count(tolower(c));
                    int up = S.count(toupper(c));
                    if (lo == 1 && up == 1) {
                        count++;
                    }
                }
                if (count == test.size()) {
                    if (test.size() > ans.size()) ans = test;
                }
            }
        }
        return ans;
    }
};
```

## 使用递归：


``` python
class Solution:
    def longestNiceSubstring(self, s: str) -> str:
        if len(s) < 2:
            return ""
        for i, c in enumerate(s):
            if c.upper() not in s or c.lower() not in s:
                return max(self.longestNiceSubstring(s[:i]), self.longestNiceSubstring(s[i+1:]), key = len)
        return s
```

## 使用前缀和：

遍历字符串，预处理前缀和数组 `sum[i][j]` 表示字符串 s 的前 i 个字符，每个字符 j 出现的次数

那么任意一个区间 l 到 r，所代表的子串中任意字符 i 的词频就是

`ans[i] = sum[r + 1][i] - sum[l][i]`



依据前缀和数组遍历每一个子串，判断大小写是否同时出现
``` cpp
class Solution {
public:
    string longestNiceSubstring(string s) {
        string ans = "";
        int n = s.size();
        vector<vector<int>> lowerCount(n + 1, vector<int>(26, 0));
        vector<vector<int>> upperCount(n + 1, vector<int>(26, 0));

        for (int i = 1; i <= n; i++) {
            char c = s[i - 1];
            lowerCount[i] = lowerCount[i - 1];
            upperCount[i] = upperCount[i - 1];
            if (c >= 'a' && c <= 'z') {
                lowerCount[i][c - 'a']++;
            }
            if (c >= 'A' && c <= 'Z') {
                upperCount[i][c - 'A']++;
            }
        } // // 统计第一个字符到第 i 个字符中，小写字母出现的数量和大写字母出现的数量 

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                bool bb = true; // // s[k] 的统计信息是 s[k + 1] - s[k] 
                for (int k = 0; k < 26; k++) { 
                    int lowerCountInSubstr = lowerCount[i + 1][k] - lowerCount[j][k];
                    int upperCountInSubstr = upperCount[i + 1][k] - upperCount[j][k];
                    if (lowerCountInSubstr != 0 && upperCountInSubstr == 0) bb = false;
                    if (lowerCountInSubstr == 0 && upperCountInSubstr != 0) bb = false; 
                }
                if (bb == true && i - j + 1 > ans.size()) {
                    ans = s.substr(j, i - j + 1);
                }
            }
        }
        return ans;
    }
};
```

## 使用二进制优化

更进一步，对于某个子串而言，我们只关心大小写是否同时出现，而不关心出现次数。

因此我们无须使用二维数组来记录具体的词频，可以在枚举子串时，使用两个 int 的低 26 位分别记录大小写字母的出现情况，利用枚举子串时右端点后移，维护两变量，当且仅当两变量相等时，满足 26 个字母的大小写同时出现或同时不出现


``` cpp
class Solution {
public:
    string longestNiceSubstring(string s) {
        int n = s.size();
        int maxPos = 0;
        int maxLen = 0;
        for (int i = 0; i < n; ++i) {
            int lower = 0;
            int upper = 0;
            for (int j = i; j < n; ++j) {
                if (islower(s[j])) {
                    lower |= 1 << (s[j] - 'a'); // 1 << i 等于 2 的 i 次幂
                } else {
                    upper |= 1 << (s[j] - 'A');
                }
                if (lower == upper && j - i + 1 > maxLen) {
                    maxPos = i;
                    maxLen = j - i + 1;
                }
            }
        }
        return s.substr(maxPos, maxLen);
    }
};
```