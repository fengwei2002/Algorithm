[题目链接](https://leetcode-cn.com/problems/divide-two-integers/)  
[题解链接](https://leetcode-cn.com/problems/divide-two-integers/solution/lc29-fengwei2002-wei-yun-suan-mo-ni-by-f-zzmi/)

### 思路

| 被除数 a | 除数 b | 商 k  | 商的二进制表示 |
| -------- | ------ | ----- | -------------- |
| 60    | 3  | 20 |           |
| $60 = 3 * 20$   | 3  | $20 = 2^2 + 2^4$|    ${(10100)}_2$       |
| $60 = 3 * {2^4} + 3 * 2^2$ | 3 | $20 = 1 << 2 + 1 << 4$ |


| 被除数 a | 除数 b | 商 k  | 商的二进制表示 |
| -------- | ------ | ----- | -------------- |
| 10    | 3  | 3 |           |
| $10 = 3 * 3 + 1$   | 3  | $3 = 2^0 + 2^1$|    ${(11)}_2$       |
| $10 = 3 * {2^0} + 3 * 2^1 + 1$ | 3 | $3 = 1 << 0 + 1 << 2$ |


### 代码

不用管那种超过 int 范围的特殊数据， 直接 LL 计算之后进行结果判断就好了，讨论那些没意义

```cpp
// LeetCode 题解区搜索 fengwei2002
// https://github.com/fengwei2002/algorithm

class Solution {
   public:
    int divide(int dividend, int divisor) {
        typedef long long LL;
        vector<LL> exp;
        int x = dividend, y = divisor;
        
        bool minus = false; 
        if (x < 0 && y > 0 || x > 0 && y < 0) minus = true;
        // 记录负号是否存在

        LL a = abs((LL)x), b = abs((LL)y);
        for (LL i = b; i <= a; i = i + i) exp.push_back(i); 
        // a 是被除数，b 是除数， exp 中存放：b^1, b^2, b^3, b^4 ...

        LL ans = 0;
        for (int i = exp.size() - 1; i >= 0; i--) { // 对于 exp 中的每一项
            if (a >= exp[i]) {        //  如果被除数大于 exp 对应的 b^n
                a -= exp[i];          //  把对应的值在被除数中减去
                ans += 1LL << i; //  i 左移一位等于 i * 2 
            }
        }
        // 1LL 是 longlong 类型的 1

        if (minus) ans = -ans;
        if (ans > INT_MAx || ans < INT_MIN) ans = INT_MAX;
        return ans;
    }
};
```


``` cpp 
class Solution {
   public:
    int divide(int dividend, int divisor) {
        typedef long long LL;
        int x = dividend, y = divisor;
        bool minus = false;
        if (x < 0 && y > 0 || x > 0 && y < 0) minus = true;

        vector<LL> exp;
        LL a = abs((LL)x), b = abs((LL)y);
        for (LL i = b; i <= a; i = i + i) exp.push_back(i);

        LL ans = 0;
        for (int i = exp.size() - 1; i >= 0; i--) {
            if (a >= exp[i]) {
                a -= exp[i];
                ans += 1LL << i;
            }
        }

        if (minus) ans = -ans;
        if (ans > INT_MAX || ans < INT_MIN) ans = INT_MAX;

        return ans;
    }
};
```