[题目链接](https://leetcode-cn.com/problems/data-stream-as-disjoint-intervals/)  
[题解链接](https://leetcode-cn.com/problems/data-stream-as-disjoint-intervals/solution/lc352-fengwei2002-setqu-jian-he-bing-by-f3p3y/)

### 解题思路

使用 `set<pair<long long, long long> >` 维护排好序的左右区间 

对于每次插入的 x 考虑他的左右区间是否可以进行合并，可以合并则合并，不可以合并就当做 `{x, x}` pair 对插入 set 中

输出


``` cpp
            lower_bound(x)  返回大于等于x的最小的数的迭代器
            upper_bound(x)  返回大于x的最小的数的迭代器
```

### 代码

```cpp
//https://github.com/fengwei2002/algorithm

typedef long long LL;
const LL INF = 1e18;
typedef pair<LL, LL> PLL;

class SummaryRanges {
public:
    set<PLL> s;
    SummaryRanges() {
        // 在 set 中插入哨兵节点
        s.insert({-INF, -INF}), s.insert({INF, INF});
    }
    
    void addNum(int val) {
        // 左端点和右端点， set 中存储 pair 键值对，代表左右区间端点值
        auto r = s.upper_bound({val, INT_MAX});
        // 如果没有大于 {val, INT_MAX} 的就返回最大值
        auto l = r;
        l--; // 考察 val 为分界线的左右两个区间

        if (l->second >= val) return;   // 如果 x 在 l 区间右端点的左侧
        if (l->second == val - 1 && r->first == val + 1) { // 如果 x 在 l 和 r 的交界处
            s.insert({l->first, r->second});
            s.erase(l), s.erase(r);
        } else if (l->second == val - 1) { // 如果 x 只在左区间的交界处
            s.insert({l->first, val});
            s.erase(l);
        } else if (r->first == val + 1) {  // 如果 x 只在右区间的交界处
            s.insert({val, r->second});
            s.erase(r);
        } else {                           // 不能进行区间合并的话
            s.insert({val, val});
        }
    }
    
    vector<vector<int>> getIntervals() {
        vector<vector<int>> ans;
        for (auto& x : s) {
            if (x.first != -INF && x.second != INF) {
                ans.push_back({(int)x.first, (int)x.second});
            }
        }
        return ans;
    }
};
```