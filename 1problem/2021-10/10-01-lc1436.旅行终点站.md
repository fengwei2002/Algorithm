### 思路

首先遍历一遍数组，将所有 cityA_i 加入哈希表。
再遍历一遍数组，如果发现 cityB_i 不在哈希表中，则返回该城市。

遍历两次数组，哈希表的操作时间复杂度近似为字符串的长度，故总时间复杂度为 $O(n)$  

需要额外 $O(n)$ 的空间存储哈希表

### 代码

```cpp
class Solution {
  public:
    string destCity(vector<vector<string>> &paths) {
        unordered_set<string> citiesA; // unordered_set 存储唯一值

        for (auto &path : paths) {
            citiesA.insert(path[0]);
        }

        for (auto &path : paths) {
            if (citiesA.find(path[1]) == citiesA.end()) { 
                // find 如果没有找到的话 返回的是 end() 迭代器
                return path[1];
            }
        }
        return "";
    }
};
```

[题解链接](https://leetcode-cn.com/problems/destination-city/solution/lc1436-fengwei2002-ha-xi-biao-c-by-fengw-vskc/)