给定一个 n×n 的二维数组，如下所示：

```
int maze[5][5] = {

0, 1, 0, 0, 0,

0, 1, 0, 1, 0,

0, 0, 0, 0, 0,

0, 1, 1, 1, 0,

0, 0, 0, 1, 0,

};
```

它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。

数据保证至少存在一条从左上角走到右下角的路径。

#### 输入格式

第一行包含整数 n。

接下来 n 行，每行包含 n 个整数 0 或 1，表示迷宫。

#### 输出格式

输出从左上角到右下角的最短路线，如果答案不唯一，输出任意一条路径均可。

按顺序，每行输出一个路径中经过的单元格的坐标，左上角坐标为 (0,0)，右下角坐标为(n−1,n−1)。

#### 数据范围

0≤n≤1000

#### 输入样例：

```
5
0 1 0 0 0
0 1 0 1 0
0 0 0 0 0
0 1 1 1 0
0 0 0 1 0
```

#### 输出样例：

```
0 0
1 0
2 0
2 1
2 2
2 3
2 4
3 4
4 4
```

找出最短路并保存具体的路径



这道题是想让我们将最短的路进行输出

大致的思路是，遍历的时候，对于每个具体的坐标， 用 pre<pair<int, int>> 进行存储是从哪一个点遍历到的这一个点，存储他的前一个点的具体的下标

BFS 到达终点之后，结束循环

从 `g[n - 1][n - 1]` 开始考察每一个点的前一个点的坐标，存到一个数组中，然后将这个 `vetcot<pair<int, int>>` 逆序输出即可

``` cpp
class Solution {
public:
    string subStrHash(string s, int pp, int mod, int k, int hashValue) {
        string ans = "";
        // cout << s.size() << endl;
        // O(n^2)
        if (s.size() != k) {
            for (int j = 0; j < s.size() - k; j++) {
                long long val = 0;
                int i = j;
                string dummy = "";
                long long p  = 1;
                while (i < j + k) {
                    dummy.push_back(s[i]);
                    val = (val % mod + ((s[i] - 'a' + 1) % mod) * (p % mod)) % mod;
                    p = p % mod * pp % mod;
                    p = p % mod;
                    i++;
                }
                i--;
                if (dummy.size() == k && val == hashValue) {
                    ans = s.substr(j, k);
                    return ans;
                }
            }
        } else {
            cout << 1 << endl;
            long long val = 0;
            int i = 0;
            long long p = 1;
            while (i < s.size()) {
                val = (val % mod + ((s[i] - 'a' + 1) % mod) * (p % mod)) % mod;
                p = p % mod * pp % mod;
                p = p % mod;
                i++;
            }
            if (val == hashValue) {
                ans = s;
                return ans;
            }
        }

        return ans;
    }
};

// 对于字符串中的每一个字符都存在一个 val
// 给定字符串，次幂的底数，余数 mod，子串的长度 k， 用来判断是否相等的 hashValue
```

