[原题链接](https://www.acwing.com/problem/content/1455/)

## 题目截图

![20211026150753-2021-10-26-15-07-54](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/images/20211026150753-2021-10-26-15-07-54.png)

## 思路

对于 num 中的每一个数字，删除前面比 `num[i]` 大的所有数字，    
因为首位的值小比其他位置的值小，相比之下权重更高, 所以删除前面大于 `num[i]` 的所有数字就是最佳决策  

如果此时的 k 仍然存在（num 数组非严格单调递增，减去的数字数量小于目标数量 k），那么就把 ans 中的后 k 个字符全部删除，因为这时的数字删除后面的数字位，可以使最终的数字位最小，也是此时的最佳决策

最后统计前导零的个数，如果前导零的个数等于字符串的长度，说明最后的结果就是 0， 输出 0    
否则，就输出去除前导零之后的字符串   

## 代码


``` cpp 
#include <iostream>
#include <string.h>
using namespace std;

int main() {
    string nums = "";
    int k = 0;
    cin >> nums >> k;
    
    string ans = "0";
    for (int i = 0; i < nums.size(); i++) {
        while (k > 0 && nums[i] < ans.back()) {
            ans.pop_back();
            k--;
        }
        // 只要是逆序对，且 k != 0 ，就删除前面比 nums[i] 大的所有数，
        // 否则， ans 的最后面放入 nums[i]
        ans += nums[i];
    }

    // 执行去除剩余 k 的操作，依次去除 ans 最后面的元素
    while (k--) ans.pop_back();
    
    
    int i = 0;  // 统计前导零的个数
    while (i < ans.size() && ans[i] == '0') i++;
    
    if (i == ans.size()) ans = "0";
    else ans = ans.substr(i);
    
    cout << ans << endl;
    return 0;
}
```