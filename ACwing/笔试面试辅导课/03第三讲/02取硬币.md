- [题目链接](https://www.acwing.com/activity/content/problem/content/1939/)   
https://github.com/fengwei2002/algorithm

### 1487 取硬币

![20211103165914-2021-11-03-16-59-15](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/images/20211103165914-2021-11-03-16-59-15.png)

### 思路

这是一个混合背包的基础问题, n1 + n2 种硬币，n1 任意数量取，n2 每种只能取一个，

### C++

``` cpp
#include <iostream>
using namespace std;

const int N = 1e5 + 10, MOD = 1e9 + 7;
int n1, n2, m;
int f[N];

int main() {
    cin >> n1 >> n2 >> m;
    f[0] = 1;
     
    for (int i = 1; i <= n1; i++) { // 普通硬币的完全背包
        int p;     // f[i][j] 表示只取前 i 个硬币能组成 j 的组合数
        cin >> p;  // f[i][j] = f[i - 1][j] + f[i][j - p]
                   //       不选择第 i 个物品：f[i][j] = f[i - 1][j]
                   //       选择第 i 个物品：f[i][j] = f[i][j - p]
        for (int j = p; j <= m; j++) {
            f[j] = (f[j] + f[j - p]) % MOD;
        }
    }
    
    for (int i = 1; i <= n2; i++) { // 限量版硬币的 01 背包
        int p;      // f[i][j] 表示只取前 i 个硬币组成价值为 j 的组合数
        cin >> p;   // f[i][j] = f[i - 1][j] + f[i - 1][j - p]
                    //        不选择第 i 个物品：f[i][j] = f[i - 1][j]
                    //        选择第 i 个物品：f[i][j] = f[i - 1][j - p]
        for (int j = m; j >= p; j--) {
            f[j] = (f[j] + f[j - p]) % MOD;
        }
    }
    
    cout << f[m] << endl;
    
    return 0;
}
```

### GO

``` go

```