- [题目链接](https://leetcode-cn.com/problems/QTMn0o/)  
- [题解链接](https://leetcode-cn.com/problems/QTMn0o/solution/jz2-10-fengwei2002-by-kycu-861p/)

https://github.com/fengwei2002/algorithm

给定一个整数数组和一个整数 k ，请找到该数组中和为 k 的连续子数组的个数。

### 思路

- 统计前缀和
- 统计前缀和不同值的出现次数
- 遍历，将差值等于目标值的数量加入到 ans 中

### C++

``` cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> s(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            s[i] = s[i - 1] + nums[i - 1];
        }
        
        unordered_map<int, int> hash;
        int ans = 0;
        for (int i = 0; i <= n; i++) {
            if (hash[s[i] - k]) {
                ans += hash[s[i] - k];
            } 
            // 注意这里要先判断是否存在减 k 之后的值，然后再将 s[i] 加入到 hash 中
            // 因为 k == 0 的时候，hash[s[i]] == hash[s[i] - k];
            // 那样的话，每一个 s[i] 都要加入到 ans 中了
            hash[s[i]] += 1;
        }
        return ans;
    }
};
```

### GO

``` go
func subarraySum(nums []int, k int) int {
	n := len(nums)
    s := make([]int, n + 1)
    for i := 1; i < n + 1; i++ {
        s[i] = s[i - 1] + nums[i - 1];
    }

    ans := 0
    hash := make(map[int]int)
    for i := 0; i <= n; i++ {
        if hash[s[i] - k] > 0 {
            ans += hash[s[i] - k]
        }
        hash[s[i]]++
    }

    return ans
}
```