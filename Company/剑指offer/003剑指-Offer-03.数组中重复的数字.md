[题解链接](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/jz-fengwei2002-yuan-di-zhi-huan-by-kycu-ujwn/)

[题目链接](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

https://github.com/fengwei2002/algorithm

有三种写法：
- 可以使用 `unordered_map<int, int>` 用来存放数字的出现次数，等于 2 的时候结束程序
- 排序之后，相同的元素必定相邻
- 原地置换

主要看原地置换的写法：

因为题目给出的条件是
 **在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内**
所以可以将每一个数字都放到相应的下标上，如果下标中以及存在数字，那么这个数字就是重复数字


从前往后遍历数组，主要思想是把每个数放到对应的位置上，即让 `nums[i] = i`
考虑 `nums[i]`：

> 为什么选取 `nums[i]` 和 `nums[nums[i]]` 呢？，因为每次都要选取两个不同位置的元素进行交换，和判等的操作，选取这两个数字**刚刚好没有任何的边界问题**而已，写起来整洁方便，其实比如说换个相邻元素也可以

- 如果 `nums[i] == i` 说明 `nums[i]` 这个数字已经到达了属于他的位置，顺次考虑下一个数字 `nums[i + 1]`
- 如果 `nums[nums[i]] == nums[i]` 说明数组中存在两个数字的实际应该存放的位置冲突，直返回即可
- 如果 `nums[nums[i]] == nums[i]`，那我们就想要把 `nums[i]` 交换到正确的位置上，即 `swap(nums[nums[i]], nums[i])`，交换完之后如果 `nums[i] != i`，则重复进行该操作。


```go []
func findRepeatNumber(nums []int) int {
    i := 0
    for i < len(nums) {
        if nums[i] == i {
            i += 1
            continue
        } else if nums[i] == nums[nums[i]] {
            return nums[i]
        } else {
            nums[nums[i]], nums[i] = nums[i], nums[nums[i]]
        }
    }
    return -1
}
```
```c++ []
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        int i = 0;
        while (i < nums.size()) {
            if (nums[i] == i) {
                i++;
                continue;
            } else if (nums[i] == nums[nums[i]]) {
                return nums[i];
            } else {
                swap(nums[i], nums[nums[i]]);
            }
        }
        return -1;
    }
};
```
```py []
class Solution:
    def findRepeatNumber(self, nums: List[int]) -> int:
        i = 0
        while i < len(nums):
            if nums[i] == i:
                i += 1
                continue
            elif nums[nums[i]] == nums[i]:
                return nums[i]
            else:
                nums[nums[i]], nums[i] = nums[i], nums[nums[i]]
        return -1 
```
