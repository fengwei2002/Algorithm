[题目链接](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)  
[题解链接](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/jz04-fengwei2002-by-kycu-i6im/)

https://github.com/fengwei2002/algorithm

### 思路 1

考察 target 大于某一行的起始位置并且 target 小于这一行的结束位置  
那么 target 就会在这一行的数据中有可能出现，那么在这一行中进行二分查找即可  
最坏情况下需要对整个棋盘进行搜索 `O(nlogn)`  

### 代码

```cpp []
class Solution {
public:
    bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
        int n = matrix.size();
        if (n == 0) {
            return false;
        }
        int m = matrix[0].size();
        if (m == 0) {
            return false;
        }
        for (int i = 0; i < n; i++) {
            if (matrix[i][0] <= target && matrix[i][m - 1] >= target) {
                int l = 0, r = m - 1;
                while (l < r) {
                    int mid = (l + r) >> 1;
                    if (matrix[i][mid] >= target) {
                        r = mid;
                    } else {
                        l = mid + 1;
                    }
                }
                if (matrix[i][r] == target) {
                    return true;
                } else {
                    continue;
                }
            }
        }
        return false;
    }
};
```
```go []
func findNumberIn2DArray(matrix [][]int, target int) bool {
    n := len(matrix)
    if n == 0 {
        return false
    }
    m := len(matrix[0])
    if m == 0 {
        return false
    }

    for i := 0; i < n; i++ {
        if matrix[i][0] <= target && matrix[i][m - 1] >= target {
            l, r := 0, m - 1
            for l < r {
                mid := (l + r) >> 1
                if matrix[i][mid] >= target {
                    r = mid
                } else {
                    l = mid + 1
                }
            }
            if matrix[i][r] == target {
                return true
            } else {
                continue
            }
        }
    }

    return false
}
```
```python []
class Solution:
    def findNumberIn2DArray(self, matrix: List[List[int]], target: int) -> bool:
        n = len(matrix)
        if n == 0:
            return False
        m = len(matrix[0])
        if m == 0:
            return False

        for i in range(n):
            if matrix[i][0] <= target and matrix[i][-1] >= target:
                l, r = 0, m - 1
                while l < r:
                    mid = (l + r) // 2
                    if matrix[i][mid] >= target:
                        r = mid
                    else:
                        l = mid + 1
                if matrix[i][r] == target:
                    return True
                else:
                    continue
        
        return False
```

## 思路 2 

核心在于发现每个子矩阵右上角的数的性质：

x 左边的数都小于等于 x，x 下边的数都大于等于 x。

![20220129114028-2022-01-29-11-40-31](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/images/20220129114028-2022-01-29-11-40-31.png)

从矩阵的右上角开始枚举，假设枚举值为 x
- 如果 x 等于 `target`， 找到了目标值，返回 `true`
- 如果 x 小于 `target`， 则 x 左边的数字都小于 `target`， 排除一整行的数字
- 如果 x 大于 `target`， 则 x 下边的数字都大于 `target`， 排除一整列的数字

排除一整行就是让枚举的点的横坐标加一，排除一整列就是让纵坐标减一。
当我们排除完整个矩阵后仍没有找到目标值时，就说明目标值不存在，返回 `false`。

每一步排除一行或者一列，矩阵一共 n 行 m 列， 所以最多进行 `n + m` 步， 时间复杂度 `O(n + m)`

实际运行速度并没有二分快，所以时间复杂度和实际的运行效率还是不能等价的

```python []
class Solution:
    def findNumberIn2DArray(self, matrix: List[List[int]], target: int) -> bool:
        if len(matrix) == 0 or len(matrix[0]) == 0:
            return False
        n, m = len(matrix), len(matrix[0])

        x, y = 0, m - 1

        while x < n and y >= 0:
            if matrix[x][y] > target:
                y -= 1
            elif matrix[x][y] < target:
                x += 1
            elif matrix[x][y] == target:
                return True
        
        return False
```
```cpp []
class Solution {
public:
    bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
        int n = matrix.size();
        if (n == 0) {
            return false;
        }
        int m = matrix[0].size();
        if (m == 0) {
            return false;
        }

        int x = 0, y = m - 1;
        while (x < n && y >= 0) {
            if (matrix[x][y] > target) {
                y--;
            } else if (matrix[x][y] < target) {
                x++; 
            } else if (matrix[x][y] == target) {
                return true;
            }
        }

        return false;
    }
};
```
```go []
func findNumberIn2DArray(matrix [][]int, target int) bool {
    n := len(matrix)
    if n == 0 {
        return false
    } 
    m := len(matrix[0])
    if m == 0 {
        return false
    }

    x, y := 0, m - 1
    for x < n && y >= 0 {
        if matrix[x][y] < target {
            x++
        } else if matrix[x][y] > target {
            y--
        } else if matrix[x][y] == target {
            return true
        }
    }

    return false
}
```