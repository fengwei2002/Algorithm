[原题链接](https://www.acwing.com/problem/content/1457/)  
https://github.com/fengwei2002/algorithm  


## 题目截图

![20211115205912-2021-11-15-20-59-14](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/images/20211115205912-2021-11-15-20-59-14.png)

![20211115205931-2021-11-15-20-59-32](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/images/20211115205931-2021-11-15-20-59-32.png)

## 思路

TODO 约瑟夫环扩展版, 约瑟夫环问题是每次跳固定步长，这个问题是每次跳不定长的长度

简述约瑟夫环问题的解法：

https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/

1. `f[1] = 0`
2. `i > 1, f[i] = (f[i - 1] + m) % i`



n 个人，m 个数字，依次考虑所有数字



## 代码


``` cpp 
#include <iostream>

using namespace std;

const int N = 1010;

int n, m;       //n 个人, m 个数
int a[N];

int main() {
    int T;
    scanf("%d", &T);
    while (T--) {
        scanf("%d%d", &n, &m);
        for (int i = 0; i < m; i++) scanf("%d", &a[i]);

        int ans = 0;

        // 
        for (int i = 1, j = (n - 1) % m; i < n;)
        int res = 0;    //当只剩一个人的时候,他的位置是0
        for (int i = 1, j = (n - 1) % m; i < n;)    //i表示剩余人数,剩最后一人时用的是第(n-1)%m个数
        {
            i ++ ;
            j = (j + m - 1) % m;    //循环倒退，妙。可用 if( -- j < 0) j = m - 1 代替
            res = (res + a[j]) % i; //最后幸存者在剩余i个人时的位置
        }

        printf("%d\n", res);
    }

    return 0;
}
```