[原题链接](https://www.acwing.com/problem/content/1456/)  
https://github.com/fengwei2002/algorithm

## 题目截图

![20211026153053-2021-10-26-15-30-54](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/images/20211026153053-2021-10-26-15-30-54.png)

## 思路

n < 5000, 所有数字异或起来的最大值 8191

问 n 个不相同的正整数，存在的组合子集个数，由于每一个数字选择或者不选择的都是一种答案，  
所以数据量很大，考虑 DP

DP 集合表示： 所有只考虑前 i 个物品，且异或和是 j 的选法集合
DP 集合属性： 方案的数量

DP 集合来源： 依据第 i 个物品选择或者不选择，划分集合 `f[i, j]`
- `f[i, j] = f[i - 1, j]` 不选择物品 i 
- `f[i, j] = f[i - 1, j ^ a[i]]` ，选择物品 i


所以状态转移方程就是：

`f[i, j] = f[i - 1, j] + f[i - 1, j ^ a[i]]`

> TIP：用滚动数组优化二维数组的存储，实现空间的缩小

## 代码

``` cpp 
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

// 异或运算为不进位加法, 2^12 = 4096,则从 1 加到 4096 为 8192，即所有数异或和最大值是8192
const int N = 5010, M = 8192, MOD = 1e9 + 7;

int n;
int a[N];
int f[2][M];
// 偶数行对应 0 ，奇数行对应 1    f[i&1]

// 短除法判断一个数字是否是一个质数
bool is_prime(int x) {
    for (int i = 2; i <= x / i; i++)
        if (x % i == 0)
            return false;
    return true;
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];

    f[0][0] = 1; // 当有 0 个数字的时候，异或和是 0 ，有一种方案

    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < M; j++) {
            f[i & 1][j] = (f[(i - 1) & 1][j] + f[(i - 1) & 1][j ^ a[i]]) % MOD;
        }
    }
    
    int ans = 0;
    for (int i = 2; i < M; i++) {
        // 统计 n 个数字变成 2 到 M 中的质数的总次数
        if (is_prime(i)) {
            ans = (ans + f[n][i]) % MOD;
        }
    }
    cout << ans << endl;

    return 0;
}
```