[原题链接](https://www.acwing.com/problem/content/1454/)

## 题目截图

![20211026124658-2021-10-26-12-47-00](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/images/20211026124658-2021-10-26-12-47-00.png)

## 思路

前置题目：[寻找数组中的峰值](https://leetcode-cn.com/problems/find-peak-element/)

``` cpp 
class Solution {
   public:
    int findPeakElement(vector<int>& nums) {
        int l = 0, r = nums.size() - 1;
        while (l < r) {
            int mid = (l + r) >> 1;
            if (nums[mid] > nums[mid + 1]) r = mid;
            else l = mid + 1;
        }
        return r;
    }
};
```

首先考虑暴力做法：
- 从任意一个点开始，沿着一个比他小的格子，持续有限次，最终走到的位置就是一个极小值，
- 这种做法最坏情况下时间复杂度是 `O(n^2)`
- ``` cpp
            <--
  25 24 23 22 x
  -->
  x 16 17 18 19 
  5 4  3  2  1 
  ```

`O(nlogn)`解法是，  
找到中间列的最小值，  
考虑最小值左右两侧和最小值的关系   

比如找到了 R 小于 minValue 那么 minValue 的那一列就形成了一堵 R 不可以越过的墙，数据量减半

![20220122113705-2022-01-22-11-37-10](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/images/20220122113705-2022-01-22-11-37-10.png)


数据量减半之后，再对中间的那一列进行最小值的查找，数据量又可以减半

最后便可以实现在最后一列中的最小值查找（上下两堵墙），左右也是两堵墙

最坏情况下二分 `O(logn)` 次，每次二分遍历一列元素 `O(nlogn)`

## 代码


``` cpp 
// Forward declaration of queryAPI.
// int query(int x, int y);
// return int means matrix[x][y].

class Solution {
public:
    vector<int> getMinimumValue(int n) {
        // query(x, y) == matrix[x][y]
        typedef long long LL;
        const LL INF = 1e15;
        
        int l = 0, r = n - 1;
        while (l < r) {
            int mid = (l + r) >> 1;
            
            int minValueRow = 0;       // 找出第 mid 列的最小值
            LL minValue = INF;
            for (int i = 0; i < n; i++) {
                int t = query(i, mid); // matrix[i][mid]
                if (t < minValue) {
                    minValue = t;
                    minValueRow = i;
                }
            }
            
            LL leftValue = (mid > 0) ? query(minValueRow, mid - 1) : INF;
            LL rightValue = (mid <= n - 1) ? query(minValueRow, mid + 1) : INF;
                                       // 没有数字的地方等价于正无穷
            
            if (minValue < leftValue && minValue < rightValue) return {minValueRow, mid};
                                       // 如果找到的 minValue 小于左侧，小于右侧，小于当前列的任意一个值
                                       // 就说明提前找到了一组答案，返回答案
                                       
            if (leftValue < minValue) r = mid - 1;
                                       // 根据 leftValue 和 rightValue 的值二分缩小区间
            else l = mid + 1;          
        }
        
        // 现在的 l 等于 r，数据量就变成了最后一列，再最后一列中找到元素即可
        int minValueRow  = 0;
        LL minValue = INF;
        for (int i = 0; i < n; i++) {
            int t = query(i, r);
            if (t < minValue) {
                minValue = t;
                minValueRow = i;
            }
        }
        
        return {minValueRow, r};
    }
};
```