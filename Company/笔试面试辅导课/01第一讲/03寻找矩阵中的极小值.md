[原题链接](https://www.acwing.com/problem/content/1454/)

## 题目截图

![20211026124658-2021-10-26-12-47-00](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/images/20211026124658-2021-10-26-12-47-00.png)

## 思路

前置题目：https://leetcode-cn.com/problems/find-peak-element/

``` cpp 
class Solution {
   public:
    int findPeakElement(vector<int>& nums) {
        int n = nums.size() - 1;
        int l = 0, r = n;
        while (l < r) {
            int mid = (l + r + 1) >> 1;
            if (nums[mid] >= nums[mid - 1])
                l = mid;
            else
                r = mid - 1;
        }
        
        cout << l << r << endl;
        return r;
    }
};
```

从任意一个点开始，沿着一个比他小的格子，持续有限次，最终走到的位置就是一个极小值，最坏情况下时间复杂度是 `O(n^2)`


正确解法是，二分列，找到当前列的最小值，从当前列的最小值的一侧，继续二分

最后就在最后确定的那一列，进行最小值的查找

## 代码


``` cpp 
class Solution {
public:
    vector<int> getMinimumValue(int n) {
        typedef long long LL;
        const LL INF = 1e15;

        int l = 0, r = n - 1;
        while (l < r) {
            int mid = l + r >> 1;
            // 求中点

            // 求中线的最小值
            int k;
            LL val = INF;
            for (int i = 0; i < n; i++) {
                int t = query(i, mid);
                if (t < val) {
                    val = t;
                    k = i;
                }
            }

            // 越过边界的话，left 或者 right 就是正无穷
            // 没有越过边界的话，left 是 mid 列最小值的左侧元素
            //               right 是 mid 列最小值的右侧元素
            LL left = mid ? query(k, mid - 1) : INF;
            LL right = mid + 1 < n ? query(k, mid + 1) : INF;
            
            if (val < left && val < right) return {k, mid}; // 如果提前找到了找到了答案
            if (left < val) r = mid - 1;                    // 左侧小的话，说明左边一定有解
            else l = mid + 1;                               // 否则右边有解
        }

        int k;
        LL val = INF;
        for (int i = 0; i < n; i ++ ) {
            int t = query(i, r); // 二分结束之后，再寻找最后一列的最小值
            if (t < val) {
                val = t;
                k = i;
            }
        }

        // 最后的 k r 就是一个极小值
        return {k, r};
    }
};
```