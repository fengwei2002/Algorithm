![20211115200015-2021-11-15-20-00-17](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/images/20211115200015-2021-11-15-20-00-17.png)

[题目链接](https://www.acwing.com/problem/content/86/)

首先判重的第一反应就是 哈希表，开一个哈希表，如果这个节点之前已经存在，那么就直接返回

``` cpp 
class Solution {
   public:
    ListNode *entryNodeOfLoop(ListNode *head) {
        if (head == nullptr) return head;

        unordered_map<ListNode*, int> hash;
        auto p = head;
        
        while (p) {
            if (hash[p]) {
                return p;
            }
            hash[p] = 1;
            p = p->next;
        }
        
        return nullptr;
    }
};
```

## 不使用哈希表的写法：

用快慢指针记录周长，

- 定义一快一慢两个指针。慢指针一次走一步，快指针一次走两步。两个指针同时向前走，如果两个指针能相遇，则环存在。如果快指针走到下一个节点是 null，则环不存在。
- 两个指针能相遇，相遇地点一定是在环里。此时，一个指针停下来，另一个指针每次向前走一步，再次相遇时，走过的长度就是环的周长。
- 两个指针同时指向起点，一个指针先向前移动环的周长，然后两个指针同时每次向前移动一步，再次相遇时，就是环的入口。


``` cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *entryNodeOfLoop(ListNode *head) {
        if (head == nullptr || head->next == nullptr) return nullptr;
        
        auto fast = head;
        auto slow = head;
        int circleGirth = 0;
        
        while (fast->next && fast->next->next) {
            fast = fast->next->next;
            slow = slow->next;
            
            if (fast == slow) {
                // 记录环的周长
                slow = slow->next;
                circleGirth++;
                while (fast != slow) {
                    slow = slow->next;
                    circleGirth++;
                }
                
                // 将快慢指针都移动到头节点
                fast = slow = head;
                
                // 将快指针向后移动周长步
                for (int i = 0; i < circleGirth; i++) {
                    fast = fast->next;
                }
                
                // 快慢指针的步长都变为 1, 不相等的话，就依次后移
                // 直到下一次快慢指针相等，退出循环
                while (fast != slow) {
                    fast = fast->next;
                    slow = slow->next;
                }
                
                return fast;
            }
        }
        
        return nullptr;
    }
};
```