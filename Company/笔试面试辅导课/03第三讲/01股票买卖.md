[原题链接](https://www.acwing.com/problem/content/1058/)  
https://github.com/fengwei2002/algorithm  


## 题目截图

![20211117090038-2021-11-17-09-00-40](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/images/20211117090038-2021-11-17-09-00-40.png)

![20211117090102-2021-11-17-09-01-03](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/images/20211117090102-2021-11-17-09-01-03.png)

## 思路


最多两笔交易的股票买卖，对于 i 预处理两个数组，答案就是 `g[i] + f[i + 1]`


## 代码


``` cpp 
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10;

int n;
int p[N], g[N], f[N];

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> p[i];
    
    // 预处理 g[i]: 在 1 - i 中买卖一次获得的最大收益
    // 也就是统计 1 - i 中出现的最小值，然后在 1 - i 中的最大值位置卖出，预处理一个差值到 g[] 数组
    for (int i = 2, minv = p[1]; i <= n; i++) {
        g[i] = max(g[i - 1], p[i] - minv);
        minv = min(minv, p[i]);
    }
    
    // 预处理 f[i]: 在 i - n 中买卖一次获得的最大收益
    for (int i = n - 1, maxv = p[n]; i >= 1; i--) {
        f[i] = max(f[i + 1], maxv - p[i]);
        maxv = max(maxv, p[i]);
    }
    
    int ans = 0;
    for (int i = 2; i <= n; i++) ans = max(ans, g[i] + f[i + 1]);
    cout << ans << endl;
    
    return 0;
}
```


``` go

```