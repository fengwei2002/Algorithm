
小声bb：(好像遥不可及的事情去做就不是很难，成就感满满)

---

## LeetCode 1-50 题解目录

``` cpp
// LeetCode 题解区搜索关键字 fengwei2002 即可查看我的题解
// https://github.com/fengwei2002/algorithm
```

| SOLUTIONLINK | SOURCECODE | TAGS | STEPS |
| ------ | ---- | ---- | ------ |
| [0001](https://leetcode-cn.com/problems/two-sum/solution/lc1-fengwei2002-ha-xi-biao-by-fengwei200-t94y/) | [1.两数之和](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/1.两数之和.cpp) |数组 哈希表| 遍历数组的同时进行哈希表的数据存储 |
| [0002](https://leetcode-cn.com/problems/add-two-numbers/solution/lc2-fengwei2002-mo-ni-gao-jing-du-jia-fa-ng51/) | [2.两数相加](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/2.两数相加.cpp) |链表 高精度加法| 在链表上进行手算加法模拟|
| [0003](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/lc-3-fengwei2002-ha-xi-biao-by-fengwei20-nj6v/) | [3.无重复字符的最长子串](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/3.无重复字符的最长子串.cpp) |字符串 哈希表| 当出现重复字符的时候，从前往后删一直删到 `hash[s[j]] == 1` 这时的 `j - i + 1` 就是无重复字符子串的长度`hash[s[j]]++;` `while (hash[s[j]] > 1) hash[s[i++]]--;` `ans = max(ans, j - i + 1);` |
| [0004](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/lc4-fengwei2002-gao-jie-er-fen-by-fengwe-pvjd/) | [4.寻找两个正序数组的中位数](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/4.寻找两个正序数组的中位数.cpp) |数组 二分 **HARD**| 每次省略一遍 `k / 2` 之前的元素，达到数据缩减的目的|
| [0005](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/lc5-fengwei2002-shuang-zhi-zhen-by-fengw-rdy2/) | [5.最长回文子串](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/5.最长回文子串.cpp) | 字符串| 枚举每一个下标作为中点值的情况，左右扩大范围，遇到不同则结束 |
| [0006](https://leetcode-cn.com/problems/zigzag-conversion/solution/lc6-fengwei2002-zhao-gui-lu-by-fengwei20-p6nc/) | [6.z-字形变换](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/6.z-字形变换.cpp) |数组 找规律| 列举之后找规律即可 `2n - 2` 的等差数列|
| [0007](https://leetcode-cn.com/problems/reverse-integer/solution/lc7-fengwei2002-qiao-miao-chu-li-chao-gu-q0we/) | [7.整数反转](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/7.整数反转.cpp) |数组 回文串| 这个题主要可以掌握：如何优雅的判断是否越界|
| [0008](https://leetcode-cn.com/problems/string-to-integer-atoi/solution/lc8-fengwei2002-by-fengwei2002-sg6u/) | [8.字符串转换整数-atoi](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/8.字符串转换整数-atoi.cpp) |字符串 模拟| 模拟操作即可，包含上一题的处理模拟运算过程中的 `int` 整型溢出的写法|
| [0009](https://leetcode-cn.com/problems/palindrome-number/solution/lc9-fengwei2002-by-fengwei2002-8kg0/) | [9.回文数](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/9.回文数.cpp) |数组 模拟| 一种写法是同第七题，还可以转换为字符串写 `to_string() + reverse()`，注意要先将数据备份一遍，然后再进行比较|
| [0010](https://leetcode-cn.com/problems/regular-expression-matching/solution/lc10-fengwei2002-by-fengwei2002-6nmz/) | [10.正则表达式匹配](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/10.正则表达式匹配.cpp) |DP **hard**| DP经验题。只能说原题出来的时候会写就好了，两个字符串序列的问题要用二维 DP （加上类似于完全背包的一个优化）来解决|
| [0011](https://leetcode-cn.com/problems/container-with-most-water/solution/lc11-fengwei2002-by-fengwei2002-kpan/) | [11.盛最多水的容器](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/11.盛最多水的容器.cpp) |贪心 双指针| 贪心经验题，这个题也是见过就会写，左右两个指针，每次移动最小的那一个指针，即可求得最佳方案|
| [0012](https://leetcode-cn.com/problems/integer-to-roman/solution/lc12-fengwei2002-by-fengwei2002-r2an/) | [12.整数转罗马数字](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/12.整数转罗马数字.cpp) | 打表 找规律 | 如何优雅的处理罗马数字转换的问题：找出独一无二的 13 个字母串 |
| [0013](https://leetcode-cn.com/problems/roman-to-integer/solution/lc13-fengwei2002-by-fengwei2002-dfdr/) | [13.罗马数字转整数](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/13.罗马数字转整数.cpp) | 找规律 | 反方向的上一题，一个数字一个数字处理即可|
| [0014](https://leetcode-cn.com/problems/longest-common-prefix/solution/lc14-fengwei2002-by-fengwei2002-pty7/) | [14.最长公共前缀](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/14.最长公共前缀.cpp) | 字符串 | 遍历，然后在字符不同的位置返回即可 |
|[0015](https://leetcode-cn.com/problems/3sum/solution/lc15-fengwei2002-by-fengwei2002-fqnv/) | [15.三数之和](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/15.三数之和.cpp) | 双指针 | 注意这个题的去重位置，要**在找到答案之后进行去重**，要么写的会很乱|
| [0016](https://leetcode-cn.com/problems/3sum-closest/solution/lc16-fengwei2002-by-fengwei2002-9s40/) | [16.最接近的三数之和](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/16.最接近的三数之和.cpp) |双指针 细节| 注意根据 `abs()` 距离更新 `ans` 的写法|
| [0017](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/lc17-fengwei2002-by-fengwei2002-3oj4/) | [17.电话号码的字母组合](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/17.电话号码的字母组合.cpp) |DFS 回溯| 回溯框架题，遇到 dfs 题目可以画一颗树，使用全排列的思路和写法即可|
| [0018](https://leetcode-cn.com/problems/4sum/solution/lc-18-fengwei2002-by-fengwei2002-3hk4/) | [18.四数之和](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/name03.cpp) |双指针| 双指针可以将 `On^2` 优化为 `O(n)`，双指针应用写法同三数之和|
| [0019](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/solution/lc-19-fengwei2002-by-fengwei2002-e11l/) | [19.删除链表的倒数第-n-个结点](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/19.删除链表的倒数第-n-个结点.cpp) | 链表 | 用 `dummy` 节点指向头节点，`first` 指针始终和 `second` 指针距离为 n|
| [0020](https://leetcode-cn.com/problems/valid-parentheses/solution/lc20-fengwei2002-by-fengwei2002-hgve/) | [20.有效的括号](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/20.有效的括号.cpp) | 栈 模拟 | 使用栈的经典题目，可以使用哈希表存储括号进行重复代码缩减，也可以使用 ASCII 码来简写代码，，因为数据中只存在括号|
| [0021](https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/lc21-fengwei2002-by-fengwei2002-wusr/) | [21.合并两个有序链表](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/21.合并两个有序链表.cpp) |链表 归并排序| 二路归并，小的放进去，然后对传入的两个链表取空即可，类似于链表上的两数之和|
| [0022](https://leetcode-cn.com/problems/generate-parentheses/solution/lc22-fengwei2002-dfs-by-fengwei2002-5eum/) | [22.括号生成](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/22.括号生成.cpp) | DFS 回溯| 在括号匹配中，**左括号大于右括号的情况下**， 就可以继续生成括号|
| [0023](https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/lc23-fengwei2002-you-xian-ji-dui-lie-dui-rt2s/) | [23.合并k个升序链表](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/23.合并k个升序链表.cpp) |优先级队列（堆）| 放入堆中的数据已经按照从小到大进行了排序，弹出**堆顶最小**的那一个 链表，拼接到 tail 后面，再次放入 heap 中，这样每次取出来的 链表都是最小的那一个|
| [0024](https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/lc24-fengwei2002-lian-biao-mo-ni-by-feng-wo5e/) | [24.两两交换链表中的节点](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/24.两两交换链表中的节点.cpp) |链表 模拟| 建议链表题目画图理解 |
| [0025](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/lc25-fengwei2002-lian-biao-by-fengwei200-du31/) | [25.k-个一组翻转链表](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/25.k-个一组翻转链表.cpp) |链表 模拟| 还是链表，链表题目慢慢写就好了，仔细一点|
| [0026](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/lc26-fengwei2002-uniquehan-shu-by-fengwe-7ki8/) | [26.删除有序数组中的重复项](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/26.删除有序数组中的重复项.cpp) | 手写函数 | 这个 `unique` 函数写法很简洁，建议背诵|
| [0027](https://leetcode-cn.com/problems/remove-element/solution/lc27-fengwei2002-tong-lc26-by-fengwei200-8yg4/) | [27.移除元素](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/27.移除元素.cpp) | 手写函数 | `unique` 函数：只保留值不等于 `val` 的元素 `if (nums[i] != val) nums[k++] = nums[i];`|
| [0028](https://leetcode-cn.com/problems/implement-strstr/solution/lc28-fengwei2002-shou-xie-kmp-by-fengwei-0h4w/) | [28.实现-str-str](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/28.实现-str-str.cpp) | 手写函数 | `substr()` 函数KMP 没什么好说的，理解之后把它背烂就好了|
| [0029](https://leetcode-cn.com/problems/divide-two-integers/solution/lc29-fengwei2002-wei-yun-suan-mo-ni-by-f-zzmi/) | [29.两数相除](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/29.两数相除.cpp) |进制 模拟除法| 不使用除法和乘法，实现除法；用进制原理模拟除法|
| [0030](https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/solution/lc30-fengwei2002-ha-xi-biao-hua-dong-chu-17hz/) | [30.串联所有单词的子串](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/30.串联所有单词的子串.cpp) |哈希表 滑动窗口 **HARD**| 按照起始位置对于 `wordlength` 的余数分组起始位置， 考察滑动窗口中的某一个单词对应的数量和标准数量的差别，遇到正确匹配放入结果中 |
| [0031](https://leetcode-cn.com/problems/next-permutation/solution/lc-fengwei2002-zhao-gui-lu-by-fengwei200-w72c/) | [31.下一个排列](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/31.下一个排列.cpp) | 思维题 | 从后往前找到第一个非逆序的数字，从这个数字从前往后开始找大于他的最小的那一个数字， 交换两个数字，然后要让从这个数字之后的数字排列最小，所以再执行 `reverse(nums.begin() + k, nums.end())`|
| [0032](https://leetcode-cn.com/problems/longest-valid-parentheses/solution/lc32-fengwei2002-zhan-de-gao-nan-du-ying-uaye/) | [32.最长有效括号](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/32.最长有效括号.cpp) |栈 **HRAD**| 计算每一个右括号对应的合法区间的最大长度，长度值是 栈中未匹配的左括号的下一个坐标|
| [0033](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/lc-33-fengwei200-liang-ci-er-fen-by-feng-j6s5/) | [33.搜索旋转排序数组](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/33.搜索旋转排序数组.cpp) | 二分查找 | 两次二分查找，第一次确定递增区间结束的位置，第二次依据 `target` 的值，确定要在哪一个区间中进行 `target` 的二分查找|
| [0034](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/lc34-fengwei2002-liang-ci-er-fen-cha-zha-j2ys/) | [34.在排序数组中查找元素的第一个和最后一个位置](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/34.在排序数组中查找元素的第一个和最后一个位置.cpp) | 二分查找 | 两次二分查找，二分查找经典模板题|
| [0035](https://leetcode-cn.com/problems/search-insert-position/solution/lc35-fengwei2002-er-fen-mo-ban-ti-by-fen-4i6e/) | [35.搜索插入位置](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/35.搜索插入位置.cpp) | 二分查找 | 一次二分查找，注意大于 `target` 的要返回 `l + 1` 即可，遇到二分调一调|
| [0036](https://leetcode-cn.com/problems/valid-sudoku/solution/lc36-fengwei2002-cbao-li-by-fengwei2002-yby9/) | [36.有效的数独](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/36.有效的数独.cpp) |模拟 暴力| 直接开一个 `bool[9]`,： 搜索行，搜索列，搜索 `9 * 9` 的小方格，如果都匹配就返回 true|
| [0037](https://leetcode-cn.com/problems/sudoku-solver/solution/lc37-fengwei2002-dfs-bao-li-sou-suo-by-f-n5sv/) | [37.解数独](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/37.解数独.cpp) |DFS **HARD**|虽然是爆搜，但是快速的写对也挺麻烦，**DFS 典中典**|
| [0038](https://leetcode-cn.com/problems/count-and-say/solution/lc38-fengwei2002-mo-ni-by-fengwei2002-69c5/) | [38.外观数列](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/38.外观数列.cpp) |模拟 | 先找到第一个数字和第二个数字的边界，新字符串 += 第一个数字的数量，然后 += 第二个数字本身，然后找到第二个数字和第三个数字的边界，新字符串继续 += 第二个数字的数量，然后 += 第三个数字本身|
| [0039](https://leetcode-cn.com/problems/combination-sum/solution/lc39-fengwei2002-dfs-by-kycu-nyiq/) | [39.组合总和](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/39.组合总和.cpp) |DFS| 回溯框架题，因为每个元素可以取任意次，所以 dfs 传入的下标还是 i|
| [0040](https://leetcode-cn.com/problems/combination-sum-ii/solution/lc40-fengwei2002-dfs-by-kycu-ipby/) | [40.组合总和-ii](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/40.组合总和-ii.cpp) | DFS | **值得琢磨**，相比于上一题，加了树的同一层的数字不能相等的条件，树枝上面的数字可以相同，所以可以先对 `candidates` 数组进行排序，如果当前元素在同一层的树中出现过则跳过 `dfs` 下标为 `i + 1` 因为当前元素只使用一次 |
| [0041](https://leetcode-cn.com/problems/first-missing-positive/solution/lc41-fengwei2002-si-wei-ti-by-kycu-p4l2/) | [41.缺失的第一个正数](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/41.缺失的第一个正数.cpp) |哈希表 思维题| 类似于去重函数的写法，把每一个 `nums[i]` 放到该放的位置，然后从前往后进行遍历，那么出现 `nums[i] != i` 的位置就是答案|
| [0042](https://leetcode-cn.com/problems/trapping-rain-water/solution/lc42-fengwei2002-xun-huan-huo-zhan-by-ky-my7l/) | [42.接雨水](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/42.接雨水.cpp) | 思维题 单调栈 | 用三次循环：`leftMax + rightMax + ans` 或者用单调栈|
| [0043](https://leetcode-cn.com/problems/multiply-strings/solution/lc43-fengwei2002-gao-jing-du-cheng-fa-by-nd65/) | [43.字符串相乘](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/43.字符串相乘.cpp) | 高精度乘法 | 与常见的高精度乘法不同，这里是高精度乘以高精度，`C[i + j] += A[i] * B[j]`, 然后 `t += C[i], C[i] = t % 10` , `t /= 10`, 最后去除前导零|
| [0044](https://leetcode-cn.com/problems/wildcard-matching/solution/lc44-fengwei2002-dp-by-kycu-oqy2/) | [44.通配符匹配](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/44.通配符匹配.cpp) | DP `HARD`| 和第 10 题 正则表达式匹配 DP 分析过程很像，包括他们的 DP 优化方式，都和完全背包相似，但是这个题比 10 简单一些，没有 `&&` 的部分|
| [0045](https://leetcode-cn.com/problems/jump-game-ii/solution/lc45-fengwei2002-tan-xin-by-kycu-w0ux/) | [45.跳跃游戏-ii](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/45.跳跃游戏-ii.cpp) |贪心 `HARD`| 贪心经验题，每次在上次能跳到的范围 `end` 内选择一个能跳的最远的位置（也就是能跳到 `maxPos` 位置的点）作为下次的起跳点 |
| [0046](https://leetcode-cn.com/problems/permutations/solution/lc-fengwei2002-dfs-by-kycu-bwca/) | [46.全排列](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/46.全排列.cpp) | DFS | DFS 回溯经典题目，闭眼写|
| [0047](https://leetcode-cn.com/problems/permutations-ii/solution/lc47-fengwei2002-dfs-by-kycu-kulq/) | [47.全排列-ii](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/47.全排列-ii.cpp) | DFS | `值得琢磨` 相比于上一题，这一题的输入数据并没有进行去重，所以需要手动将重复元素进行筛选 `if (i && nums[i - 1] == nums[i] && st[i - 1] == false) continue;` 直到不相同的元素，再开始进行全排列|
| [0048](https://leetcode-cn.com/problems/rotate-image/solution/lc48-fengwei2002-zhuan-zhi-ju-zhen-zai-n-037g/) | [48.旋转图像](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/48.旋转图像.cpp) | 思维题 | 现将矩阵转换为转置矩阵(`for i,j swap([i][j], [j][i])`)，然后将每一行 `reverse`|
| [0049](https://leetcode-cn.com/problems/group-anagrams/solution/lc49-fengwei2002-pai-xu-ha-xi-by-kycu-1y85/) | [49.字母异位词分组](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/49.字母异位词分组.cpp) |排序 哈希表| 将每一个字符串都进行排序后，去重输出即可 |
| [0050](https://leetcode-cn.com/problems/powx-n/solution/lc50-fengwei2002-kuai-su-mi-by-kycu-jdeg/) | [50.pow-x-n](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/50.pow-x-n.cpp) |快速幂| 快速幂模板题 ，背烂+1|


