## LeetCode 1-99 题解目录

```cpp
// https://github.com/fengwei2002/algorithm
```


| SOLUTION                                                     | AC_CODE                                                      | TAGS                    |                       ALGORITHM_STEPS                        |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------------- | :----------------------------------------------------------: |
| [0001 题解](https://leetcode.cn/problems/two-sum/solution/lc1-fengwei2002-ha-xi-biao-by-fengwei200-t94y/) | [1.两数之和](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/1.两数之和.cpp) | 数组 哈希表             |              遍历数组的同时进行哈希表的数据存储              |
| [0002 题解](https://leetcode.cn/problems/add-two-numbers/solution/lc2-fengwei2002-mo-ni-gao-jing-du-jia-fa-ng51/) | [2.两数相加](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/2.两数相加.cpp) | 链表 高精度加法         |                   在链表上进行手算加法模拟                   |
| [0003 题解](https://leetcode.cn/problems/longest-substring-without-repeating-characters/solution/lc-3-fengwei2002-ha-xi-biao-by-fengwei20-nj6v/) | [3.无重复字符的最长子串](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/3.无重复字符的最长子串.cpp) | 链表 高精度加法         | 当出现重复字符的时候，从前往后删一直删到`hash[s[j]] == 1` 这时的 `j - i + 1` 就是无重复字符子串的长度 `hash[s[j]]++;` `while (hash[s[j]] > 1) hash[s[i++]]--;` `ans = max(ans, j - i + 1);` |
| [0004 题解](https://leetcode.cn/problems/median-of-two-sorted-arrays/solution/lc4-fengwei2002-gao-jie-er-fen-by-fengwe-pvjd/) | [4.寻找两个正序数组的中位数](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/4.寻找两个正序数组的中位数.cpp) | 数组 二分**HARD**       |      每次省略一遍`k / 2` 之前的元素，达到数据缩减的目的      |
| [0005 题解](https://leetcode.cn/problems/longest-palindromic-substring/solution/lc5-fengwei2002-shuang-zhi-zhen-by-fengw-rdy2/) | [5.最长回文子串](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/5.最长回文子串.cpp) | 字符串                  | 枚举每一个下标作为中点值的情况，左右扩大范围，遇到不同则结束 |
| [0006 题解](https://leetcode.cn/problems/zigzag-conversion/solution/lc6-fengwei2002-zhao-gui-lu-by-fengwei20-p6nc/) | [6.z-字形变换](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/6.z-字形变换.cpp) | 数组 找规律             | 列举之后找规律即可，第一行和最后一行是单个公差为`2n - 2` 的等差数列，中间的行是两个公差为 `2n - 2` 的数据交织在一起，注意下标是如何得出的 |
| [0007 题解](https://leetcode.cn/problems/reverse-integer/solution/lc7-fengwei2002-qiao-miao-chu-li-chao-gu-q0we/) | [7.整数反转](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/7.整数反转.cpp) | 数组 回文串             |    写了这个题主要可以掌握：如何优雅的判断 INT32 是否越界     |
| [0008 题解](https://leetcode.cn/problems/string-to-integer-atoi/solution/lc8-fengwei2002-by-fengwei2002-sg6u/) | [8.字符串转换整数-atoi](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/8.字符串转换整数-atoi.cpp) | 字符串 模拟             | 模拟操作即可，包含上一题的处理模拟运算过程中的`int` 整型溢出的写法，当 `ans > (INT_MAX - x) / 10` 的时候，根据正负数选择返回值 |
| [0009 题解](https://leetcode.cn/problems/palindrome-number/solution/lc9-fengwei2002-by-fengwei2002-8kg0/) | [9.回文数](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/9.回文数.cpp) | 数组 模拟               | 一种写法是同第七题，还可以转换为字符串写`to_string() + reverse()`，注意要先将数据备份一遍，然后再进行比较 |
| [0010 题解](https://leetcode.cn/problems/regular-expression-matching/solution/lc10-fengwei2002-by-fengwei2002-6nmz/) | [10.正则表达式匹配](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/10.正则表达式匹配.cpp) | DP  **HARD**            | DP经验题。只能说原题出来的时候会写就好了，两个字符串序列的问题要用二维 DP （加上类似于完全背包的一个优化）来解决 |
| [0011 题解](https://leetcode.cn/problems/container-with-most-water/solution/lc11-fengwei2002-by-fengwei2002-kpan/) | [11.盛最多水的容器](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/11.盛最多水的容器.cpp) | 贪心 双指针             | 贪心经验题，这个题也是见过就会写，左右两个指针，每次移动最小的那一个指针，即可求得最佳方案 |
| [0012 题解](https://leetcode.cn/problems/integer-to-roman/solution/lc12-fengwei2002-by-fengwei2002-r2an/) | [12.整数转罗马数字](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/12.整数转罗马数字.cpp) | 打表 找规律             | 找出独一无二的 13 个字母串以及对应的数字，所有的数字表示都可以根据这十三个数字组合而成（和阿拉伯数字相同从高位到低位进行数字表示） |
| [0013 题解](https://leetcode.cn/problems/roman-to-integer/solution/lc13-fengwei2002-by-fengwei2002-dfdr/) | [13.罗马数字转整数](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/13.罗马数字转整数.cpp) | 找规律                  | 反方向的上一题，一个数字一个数字处理即可，如果遍历到的新字母比之气那的字母小，就不变， |
| [0014 题解](https://leetcode.cn/problems/longest-common-prefix/solution/lc14-fengwei2002-by-fengwei2002-pty7/) | [14.最长公共前缀](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/14.最长公共前缀.cpp) | 字符串                  | 写一个死循环，如果超出 `strs[0]` 的范围，就可以返回，如果遇到某个字符串的第 i 位和 `strs[0][i]` 不相等，也可以直接返回 |
| [0015 题解](https://leetcode.cn/problems/3sum/solution/lc15-fengwei2002-by-fengwei2002-fqnv/) | [15.三数之和](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/15.三数之和.cpp) | 双指针                  | 第一层进行直接遍历，第二层和第三层可以用双指针进行优化，注意这个题的去重位置，要**在找到答案之后进行去重**，要么写的会很乱 |
| [0016 题解](https://leetcode.cn/problems/3sum-closest/solution/lc16-fengwei2002-by-fengwei2002-9s40/) | [16.最接近的三数之和](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/16.最接近的三数之和.cpp) | 双指针 细节             |            注意根据`abs()` 距离更新 `ans` 的写法             |
| [0017 题解](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solution/lc17-fengwei2002-by-fengwei2002-3oj4/) | [17.电话号码的字母组合](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/17.电话号码的字母组合.cpp) | DFS 回溯                | 回溯框架题，遇到 dfs 题目可以画一颗树，使用全排列的思路和写法即可 |
| [0018 题解](https://leetcode.cn/problems/4sum/solution/lc-18-fengwei2002-by-fengwei2002-3hk4/) | [18.四数之和](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/name03.cpp) | 双指针                  |  双指针可以将`On^2` 优化为 `O(n)`，双指针应用写法同三数之和  |
| [0019 题解](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/lc-19-fengwei2002-by-fengwei2002-e11l/) | [19.删除链表的倒数第-n-个结点](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/19.删除链表的倒数第-n-个结点.cpp) | 链表                    | 用`dummy` 节点指向头节点，`first` 指针始终和 `second` 指针距离为 n |
| [0020 题解](https://leetcode.cn/problems/valid-parentheses/solution/lc20-fengwei2002-by-fengwei2002-hgve/) | [20.有效的括号](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/20.有效的括号.cpp) | 栈 模拟                 | 使用栈的经典题目，可以使用哈希表存储括号进行重复代码缩减，也可以使用 ASCII 码来简写代码，，因为数据中只存在括号 |
| [0021 题解](https://leetcode.cn/problems/merge-two-sorted-lists/solution/lc21-fengwei2002-by-fengwei2002-wusr/) | [21.合并两个有序链表](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/21.合并两个有序链表.cpp) | 链表 归并排序           | 二路归并，小的放进去，然后对传入的两个链表取空即可，类似于链表上的两数之和 |
| [0022 题解](https://leetcode.cn/problems/generate-parentheses/solution/lc22-fengwei2002-dfs-by-fengwei2002-5eum/) | [22.括号生成](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/22.括号生成.cpp) | DFS 回溯                | 在括号匹配中，**左括号大于右括号的情况下**， 就可以继续生成括号 |
| [0023 题解](https://leetcode.cn/problems/merge-k-sorted-lists/solution/lc23-fengwei2002-you-xian-ji-dui-lie-dui-rt2s/) | [23.合并k个升序链表](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/23.合并k个升序链表.cpp) | 优先级队列（堆）        | 放入堆中的数据已经按照从小到大进行了排序，弹出**堆顶最小**的那一个 链表，拼接到 tail 后面，再次放入 heap 中，这样每次取出来的 链表都是最小的那一个 |
| [0024 题解](https://leetcode.cn/problems/swap-nodes-in-pairs/solution/lc24-fengwei2002-lian-biao-mo-ni-by-feng-wo5e/) | [24.两两交换链表中的节点](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/24.两两交换链表中的节点.cpp) | 链表 模拟               |                     建议链表题目画图理解                     |
| [0025 题解](https://leetcode.cn/problems/reverse-nodes-in-k-group/solution/lc25-fengwei2002-lian-biao-by-fengwei200-du31/) | [25.k-个一组翻转链表](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/25.k-个一组翻转链表.cpp) | 链表 模拟               |           还是链表，链表题目慢慢写就好了，仔细一点           |
| [0026 题解](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/solution/lc26-fengwei2002-uniquehan-shu-by-fengwe-7ki8/) | [26.删除有序数组中的重复项](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/26.删除有序数组中的重复项.cpp) | 手写函数                |            这个`unique` 函数写法很简洁，建议背诵             |
| [0027 题解](https://leetcode.cn/problems/remove-element/solution/lc27-fengwei2002-tong-lc26-by-fengwei200-8yg4/) | [27.移除元素](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/27.移除元素.cpp) | 手写函数                | `unique` 函数：只保留值不等于 `val` 的元素 `if (nums[i] != val) nums[k++] = nums[i];` |
| [0028 题解](https://leetcode.cn/problems/implement-strstr/solution/lc28-fengwei2002-shou-xie-kmp-by-fengwei-0h4w/) | [28.实现-str-str](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/28.实现-str-str.cpp) | 手写函数                |   `substr()` 函数KMP 没什么好说的，理解之后把它背会就好了    |
| [0029 题解](https://leetcode.cn/problems/divide-two-integers/solution/lc29-fengwei2002-wei-yun-suan-mo-ni-by-f-zzmi/) | [29.两数相除](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/29.两数相除.cpp) | 进制 模拟除法           | 不使用除法和乘法，实现除法；用进制原理模拟除法,`for (int i = b; i <= a; i = i + i)`把 i 放入 exp 数组中，然后对于 `exp[i]` a 进行递减， `ans += 1LL << i` |
| [0030 题解](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/solution/lc30-fengwei2002-ha-xi-biao-hua-dong-chu-17hz/) | [30.串联所有单词的子串](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/30.串联所有单词的子串.cpp) | 哈希表 滑动窗口**HARD** | 按照起始位置对于`wordlength` 的余数分组起始位置， 考察滑动窗口中的某一个单词对应的数量和标准数量的差别，遇到正确匹配放入结果中 |
| [0031 题解](https://leetcode.cn/problems/next-permutation/solution/lc-fengwei2002-zhao-gui-lu-by-fengwei200-w72c/) | [31.下一个排列](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/31.下一个排列.cpp) | 模拟 找规律             | 手写 `next_permutation` 函数，从后往前找，找到第一个下降的位置，记为 `nums[k]`。注意 `nums[k]` 以后的位置是降序的。从 `nums[k]` 往后找，找到最小的比 `nums[k - 1]` 要大的数，将两者交换。注意此时 nums[k] 以后的位置仍然是降序的。直接将 k 以后的部分翻转（变为升序）。 |
| [0032 题解](https://leetcode.cn/problems/longest-valid-parentheses/solution/lc32-fengwei2002-zhan-de-gao-nan-du-ying-uaye/) | [32.最长有效括号](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/32.最长有效括号.cpp) | 栈    **HRAD**          | 计算每一个右括号对应的合法区间的最大长度，长度值是 栈中未匹配的左括号的下一个坐标 |
| [0033 题解](https://leetcode.cn/problems/search-in-rotated-sorted-array/solution/lc-33-fengwei200-liang-ci-er-fen-by-feng-j6s5/) | [33.搜索旋转排序数组](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/33.搜索旋转排序数组.cpp) | 二分查找                | 两次二分查找，第一次确定递增区间结束的位置，第二次依据`target` 的值，确定要在哪一个区间中进行 `target` 的二分查找 |
| [0034 题解](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/lc34-fengwei2002-liang-ci-er-fen-cha-zha-j2ys/) | [34.在排序数组中查找元素的第一个和最后一个位置](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/34.在排序数组中查找元素的第一个和最后一个位置.cpp) | 二分查找                |               两次二分查找，二分查找经典模板题               |
| [0035 题解](https://leetcode.cn/problems/search-insert-position/solution/lc35-fengwei2002-er-fen-mo-ban-ti-by-fen-4i6e/) | [35.搜索插入位置](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/35.搜索插入位置.cpp) | 二分查找                | 一次二分查找，注意大于`target` 的要返回 `l + 1` 即可，遇到二分调一调 |
| [0036 题解](https://leetcode.cn/problems/valid-sudoku/solution/lc36-fengwei2002-cbao-li-by-fengwei2002-yby9/) | [36.有效的数独](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/36.有效的数独.cpp) | 模拟 暴力               | 直接开一个`bool[9]`,： 搜索行，搜索列，搜索 `9 * 9` 的小方格，如果都匹配就返回 true |
| [0037 题解](https://leetcode.cn/problems/sudoku-solver/solution/lc37-fengwei2002-dfs-bao-li-sou-suo-by-f-n5sv/) | [37.解数独](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/37.解数独.cpp) | DFS  **HARD**           |      虽然是爆搜，但是快速的写对也挺麻烦，**DFS 典中典**      |
| [0038 题解](https://leetcode.cn/problems/count-and-say/solution/lc38-fengwei2002-mo-ni-by-fengwei2002-69c5/) | [38.外观数列](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/38.外观数列.cpp) | 模拟 双指针             | 先找到第一个数字和第二个数字的边界，新字符串 += 第一个数字的数量，然后 += 第二个数字本身，然后找到第二个数字和第三个数字的边界，新字符串继续 += 第二个数字的数量，然后 += 第三个数字本身，使用双指针统计重复字符的数量 |
| [0039 题解](https://leetcode.cn/problems/combination-sum/solution/lc39-fengwei2002-dfs-by-kycu-nyiq/) | [39.组合总和](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/39.组合总和.cpp) | DFS                     | 回溯框架题，因为每个元素可以取任意次，所以 dfs 传入的下标还是 i |
| [0040 题解](https://leetcode.cn/problems/combination-sum-ii/solution/lc40-fengwei2002-dfs-by-kycu-ipby/) | [40.组合总和-ii](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/40.组合总和-ii.cpp) | DFS                     | **值得琢磨**，相比于上一题，加了树的同一层的数字不能相等的条件，树枝上面的数字可以相同，所以可以先对 `candidates` 数组进行排序，如果当前元素在同一层的树中出现过则跳过 `dfs` 下标为 `i + 1` 因为当前元素只使用一次 |
| [0041 题解](https://leetcode.cn/problems/first-missing-positive/solution/lc41-fengwei2002-si-wei-ti-by-kycu-p4l2/) | [41.缺失的第一个正数](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/41.缺失的第一个正数.cpp) | 哈希表 思维题           | 类似于去重函数的写法，把每一个`nums[i]` 放到该放的位置，然后从前往后进行遍历，那么出现 `nums[i] != i` 的位置就是答案 |
| [0042 题解](https://leetcode.cn/problems/trapping-rain-water/solution/lc42-fengwei2002-xun-huan-huo-zhan-by-ky-my7l/) | [42.接雨水](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/42.接雨水.cpp) | 思维题 单调栈           |     用三次循环：`leftMax + rightMax + ans` 或者用单调栈      |
| [0043 题解](https://leetcode.cn/problems/multiply-strings/solution/lc43-fengwei2002-gao-jing-du-cheng-fa-by-nd65/) | [43.字符串相乘](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/43.字符串相乘.cpp) | 模拟 高精度乘法         | 模拟高精度乘以高精度，先将**逆序存储的 a b 的每一位**相乘统计到 C 中，不考虑进位，`C[i + j] += A[i] * B[j]`,  然后从最低位(`c[0]`)开始考虑 c 的存储 `t += C[i], C[i] = t % 10` , `t /= 10`, 最后去除前导零输出即可 |
| [0044 题解](https://leetcode.cn/problems/wildcard-matching/solution/lc44-fengwei2002-dp-by-kycu-oqy2/) | [44.通配符匹配](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/44.通配符匹配.cpp) | DP  **HARD**            | 和第 10 题 正则表达式匹配 DP 分析过程很像，包括他们的 DP 优化方式，都和完全背包相似，但是这个题比 10 简单一些，没有`&&` 的部分 |
| [0045 题解](https://leetcode.cn/problems/jump-game-ii/solution/lc45-fengwei2002-tan-xin-by-kycu-w0ux/) | [45.跳跃游戏-ii](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/45.跳跃游戏-ii.cpp) | 贪心**HARD**            | 贪心经验题，每次在上次能跳到的范围`end` 内选择一个能跳的最远的位置（也就是能跳到 `maxPos` 位置的点）作为下次的起跳点 |
| [0046 题解](https://leetcode.cn/problems/permutations/solution/lc-fengwei2002-dfs-by-kycu-bwca/) | [46.全排列](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/46.全排列.cpp) | DFS                     |                   DFS 回溯经典题目，闭眼写                   |
| [0047 题解](https://leetcode.cn/problems/permutations-ii/solution/lc47-fengwei2002-dfs-by-kycu-kulq/) | [47.全排列-ii](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/47.全排列-ii.cpp) | DFS                     | `值得琢磨` 相比于上一题，这一题的输入数据并没有进行去重，所以需要手动将重复元素进行筛选 `if (i && nums[i - 1] == nums[i] && st[i - 1] == false) continue;` 直到不相同的元素，再开始进行全排列 |
| [0048 题解](https://leetcode.cn/problems/rotate-image/solution/lc48-fengwei2002-zhuan-zhi-ju-zhen-zai-n-037g/) | [48.旋转图像](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/48.旋转图像.cpp) | 思维题                  | 现将矩阵转换为转置矩阵(`for i,j swap([i][j], [j][i])`)，然后将每一行 `reverse` |
| [0049 题解](https://leetcode.cn/problems/group-anagrams/solution/lc49-fengwei2002-pai-xu-ha-xi-by-kycu-1y85/) | [49.字母异位词分组](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/49.字母异位词分组.cpp) | 排序 哈希表             |           将每一个字符串都进行排序后，去重输出即可           |
| [0050 题解](https://leetcode.cn/problems/powx-n/solution/lc50-fengwei2002-kuai-su-mi-by-kycu-jdeg/) | [50.pow-x-n](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/50.pow-x-n.cpp) | 快速幂                  |                    快速幂模板题 ，背会+1                     |
| [0051 题解](https://leetcode.cn/problems/n-queens/solution/lc51-fengwei2002-dfs-by-kycu-clwn/) | [51.n-皇后](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/51.n-皇后.cpp) | DFS                     |     典中典，用 `u - i + n` 和 `u + i` 表示对角线 dg，udg     |
| [0052 题解](https://leetcode.cn/problems/n-queens-ii/solution/lc52-fengwei2002-dfs-by-kycu-f4wm/) | [52.n皇后-ii](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/52.n皇后-ii.cpp) | DFS                     | 同上一题，这个题不用进行 `board` 的存储，只用三个 `bool` 数组即可完成 |
| [0053 题解](https://leetcode.cn/problems/maximum-subarray/solution/lc53-fengwei2002-ji-chu-dp-by-kycu-zhl0/) | [53.最大子序和](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/53.最大子序和.cpp) | DP                      |      基础 DP，`f[i] = max(f[i - 1] + nums[i], nums[i])`      |
| [0054 题解](https://leetcode.cn/problems/spiral-matrix/solution/lc54-fengwei2002-pian-yi-liang-shu-zu-by-0hal/) | [54.螺旋矩阵](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/54.螺旋矩阵.cpp) | 模拟                    |        方向向量数组 dx 和 dy 的使用，使得代码极其美观        |
| [0055 题解](https://leetcode.cn/problems/jump-game/solution/lc55-fengwei2002-by-kycu-p3f2/) | [55.跳跃游戏](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/55.跳跃游戏.cpp) | 贪心                    |          贪心经验题，记录每次的可以跳到的最远的位置          |
| [0056 题解](https://leetcode.cn/problems/merge-intervals/solution/lc56-fengwei2002-da-mo-ni-by-kycu-p81r/) | [56.合并区间](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/56.合并区间.cpp) | 模拟                    | 典中典大模拟，按照左区间的端点对 pair 进行排序，如果下一个的左端点小于当前的右端点，那么就进行合并，否则不进行合并 |
| [0057 题解](https://leetcode.cn/problems/insert-interval/solution/lc57-fengwei2002-mo-ni-by-kycu-f004/) | [57.插入区间](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/57.插入区间.cpp) | 模拟                    | 前面的有序部分直接放入结果中，中间有重叠的部分合并后放入结果中，后半部分直接放入结果中 |
| [0058 题解](https://leetcode.cn/problems/length-of-last-word/solution/lc58-fengwei2002wang-su-ti-by-kycu-4e6h/) | [58.最后一个单词的长度](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/58.最后一个单词的长度.cpp) | 模拟                    | 可以使用 stringstream 直接进行读入，每次更新读入单词的长度，输出最后一个长度，也可以逆序遍历用两个指针来记录单词的起始位置和结束位置 |
| [0059 题解](https://leetcode.cn/problems/spiral-matrix-ii/solution/lc59-fengwei2002pian-yi-liang-shu-zu-by-ccb44/) | [59.螺旋矩阵-ii](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/59.螺旋矩阵-ii.cpp) | 模拟                    |            同螺旋矩阵，使用偏移量数组进行方向控制            |
| [0060 题解](https://leetcode.cn/problems/permutation-sequence/solution/lc60-fengwei2002-ji-shu-fa-by-kycu-wpwd/) | [60.排列序列](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/60.排列序列.cpp) | 计数法  **HARD**        |             考察每个位置确定之后的剩余排列的数量             |
| [0061 题解](https://leetcode.cn/problems/rotate-list/solution/lc61-fengwei2002-lian-biao-mo-ni-by-kycu-q859/) | [61.旋转链表](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/61.旋转链表.cpp) | 链表 模拟               | 将链表成环之后，从链表末尾节点向后移动 add 次，重新断开环即可 |
| [0062 题解](https://leetcode.cn/problems/unique-paths/solution/lc62-fengwei2002-dp-by-kycu-nw8y/) | [62.不同路径](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/62.不同路径.cpp) | DP                      | 经典 DP，用 `f[n][m]` 代表 路径数量， `f[n][m] = f[n - 1][m] + f[n][m - 1]` |
| [0063 题解](https://leetcode.cn/problems/unique-paths-ii/solution/lc63-fengwei200-dp-by-kycu-4oc4/) | [63.不同路径-ii](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/63.不同路径-ii.cpp) | DP                      |    相比于上一题，加上 `if board[i][j] == 1 continue` 即可    |
| [0064 题解](https://leetcode.cn/problems/minimum-path-sum/solution/lc64-fengwei2002-dp-by-kycu-1xwa/) | [64.最小路径和](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/64.最小路径和.cpp) | DP                      |                     增加权值的 不同路径                      |
| [0065 题解](https://leetcode.cn/problems/valid-number/solution/lc65-fengwei2002-mian-xiang-yang-li-bian-krja/) | [65.有效数字](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/65.有效数字.cpp) | 模拟                    | 实现 `stof` 函数，将一个字符串转换为一个浮点数，遇到模拟题可以一一列举需要手动枚举的条件，然后再进行具体的代码实现 |
| [0066 题解](https://leetcode.cn/problems/plus-one/solution/lc66-fengwei2002-gao-jing-du-jia-fa-by-k-g03q/) | [66.加一](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/66.加一.cpp) | 高精度加法              |     高精度加法模板题，利用两次翻转可以使代码更加美观可读     |
| [0067 题解](https://leetcode.cn/problems/add-binary/solution/lc67-fengwei2002-mo-ni-by-kycu-y3mu/) | [67.二进制求和](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/67.二进制求和.cpp) | 高精度加法              |                      高精度加法模板题++                      |
| [0068 题解](https://leetcode.cn/problems/text-justification/solution/lc68-fengwei2002-by-kycu-cts9/) | [68.文本左右对齐](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/68.文本左右对齐.go) | 模拟                    |                            大模拟                            |
| [0069 题解](https://leetcode.cn/problems/sqrtx/solution/lc69-fengwei2002-fu-dian-shu-er-fen-by-k-q2ia/) | [69.x-的平方根](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/69.x-的平方根.cpp) | 二分                    |                       浮点数二分典中典                       |
| [0070 题解](https://leetcode.cn/problems/climbing-stairs/solution/lc70-fengwei2002-dp-by-kycu-kfe0/) | [70.爬楼梯](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/70.爬楼梯.cpp) | DP                      |            简单 DP： `f[i] = f[i - 1] + f[i - 2]`            |
| [0071 题解](https://leetcode.cn/problems/simplify-path/solution/lc71-fengwei2002-by-kycu-z3ke/) | [71.简化路径](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/71.简化路径.cpp) | 栈模拟                  | 用两个字符串模拟栈的操作，遇到 `.` 不作为，遇到 `..` 弹出上一段路径，否则就正常加入结果路径 |
| [0072 题解](https://leetcode.cn/problems/edit-distance/solution/lc72-fengwei2002-jing-dian-dp-by-kycu-g3oe/) | [72.编辑距离](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/72.编辑距离.cpp) | DP                      | 经典 DP 问题，将 `f[i][j]` 分为四种情况，取最小值, `f[i, j] = f[i - 1][j - 1] + 1 || f[i, j] = f[i - 1][j - 1]` , `f[i, j] = f[i - 1, j] + 1`, `f[i , j] = f[i, j - 1] + 1` |
| [0073 题解](https://leetcode.cn/problems/set-matrix-zeroes/solution/lc73-fengwei2002-by-kycu-z34l/) | [73.矩阵置零](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/73.矩阵置零.cpp) | 模拟 矩阵               | 背过，基本不可能自己想出来。用两个变量记录第一行和第一列是否有 0，遍历整个矩阵，用矩阵的第一行和第一列记录对应的行和列是否有 0。把含有 0 的行和列都置成 0。 |
| [0074 题解](https://leetcode.cn/problems/search-a-2d-matrix/solution/lc74-fengwei2002-er-fen-by-kycu-0llk/) | [74.搜索二维矩阵](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/74.搜索二维矩阵.cpp) | 模拟 矩阵               |        注意一个值对于矩阵映射之后的，行和列对应的下标        |
| [0075 题解](https://leetcode.cn/problems/sort-colors/solution/lc75-fengwei2002-by-kycu-3ivm/) | [75.颜色分类](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/75.颜色分类.cpp) | 三指针 快速排序         | 用 j i k 代表 0 1 2 的下标，i < k 的时候进行原地的数组交换，或者将 vector 转换为 数组，直接背快排模板 |
| [0076 题解](https://leetcode.cn/problems/minimum-window-substring/solution/lc76-fengwei2002-by-kycu-o6ua/) | [76.最小覆盖子串](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/76.最小覆盖子串.cpp) | 滑动窗口 **HARD**       |                     思想同第 30 题，TODO                     |
| [0077 题解](https://leetcode.cn/problems/combinations/solution/lc77-fengwei2002-dfs-by-kycu-onsw/) | [77.组合](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/77.组合.cpp) | DFS                     |       DFS 典中典，注意仔细考虑向下一次迭的参数具体传值       |
| [0078 题解](https://leetcode.cn/problems/subsets/solution/lc78-fengwei2002-by-kycu-qc7s/) | [78.子集](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/78.子集.cpp) | DFS                     |      dfs谁都会，但是这个可以用二进制的迭代写法，很经典       |
| [0079 题解](https://leetcode.cn/problems/word-search/solution/lc79-fengwei2002-pian-yi-liang-shu-zu-df-a10y/) | [79.单词搜索](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/79.单词搜索.cpp) | DFS                     | 这是一个利用矩阵偏移量数组的 DFS，对于矩阵中的每一个下标，每次向下迭代搜索三个方向，如果搜到了` word.size() - 1, ` 就 `return true` |
| [0080 题解](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/solution/lc80-fengwei2002-by-kycu-gl1v/) | [80.删除有序数组中的重复项-ii](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/80.删除有序数组中的重复项-ii.cpp) | 链表 模拟               | 定义一个指针 k，表示新数组的末尾，然后从前往后扫描原数组，如果数组中的数字 `k > 2 || nums[k - 1] || nums[k - 2]`，`nums[k++] = i` |
| [0081 题解](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/solution/lc81-fengwei2002-by-kycu-p67z/) | [81.搜索旋转排序数组-ii](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/81.搜索旋转排序数组-ii.cpp) | 双指针                  | 去除数组末尾和 `nums[0]` 相等的元素，然后一次二分找到两个区间的边界，再用一次二分查找值的位置 |
| [0082 题解](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/solution/lc82-fengwei2002-by-kycu-uhzd/) | [82.删除排序链表中的重复元素-ii](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/82.删除排序链表中的重复元素-ii.cpp) | 链表 模拟               | 如果结束 while 循环之后，c ` == a->next->next` ，`a = a->next`，如果结束 while 循环之后，c 的位置发生了改变，现在的 c 指向重复元素段的下一个元素, 所以将 `a->next` 指向 c 就可以实现跳过所有出现多次的元素 |
| [0083 题解](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/solution/lc83-fengwei2002-by-kycu-0n25/) | [83.删除排序链表中的重复元素](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/83.删除排序链表中的重复元素.cpp) | 链表 模拟               | 遍历链表，遇到不等于前一个元素的值，head 指向这一个值，head 向后移动一位 |
| [0084 题解](https://leetcode.cn/problems/largest-rectangle-in-histogram/solution/lc84-fengwei2002-by-kycu-33ky/) | [84.柱状图中最大的矩形](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/84.柱状图中最大的矩形.cpp) | 单调栈                  | 本质是找到每个柱形条左边和右边最近的比自己低的矩形条，然后用宽度乘上当前柱形条的高度作为备选答案。利用单调栈在 `O(n)` 时间内维护好左右对应的数组 |
| [0085 题解](https://leetcode.cn/problems/maximal-rectangle/solution/lc85-fengwei2002-by-kycu-fr0x/) | [85.最大矩形](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/85.最大矩形.cpp) | 单调栈                  | 特别nb的一个解法：对于 matrix 的每一行维护 h 数组，存储对应的 1 的高度，调用 84 的单调栈计算最大面积的矩形函数即可 |
| [0086 题解](https://leetcode.cn/problems/partition-list/solution/lc86-fengwei2002-by-kycu-4kri/) | [86.分隔链表](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/86.分隔链表.cpp) | 链表 模拟               |                                                              |
| [0087 题解](https://leetcode.cn/problems/scramble-string/solution/lc87-fengwei2002-by-kycu-obql/) | [87.扰乱字符串](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/87.扰乱字符串.cpp) | DP **HARD**             |               三维 DP，观赏性题目属于是。。。                |
| [0088 题解](https://leetcode.cn/problems/merge-sorted-array/solution/lc88-fengwei2002-by-kycu-rejy/) | [88.合并两个有序数组](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/88.合并两个有序数组.cpp) | 双指针                  | 避免没有被用过的数字被覆盖，从后往前，依次放入最大值，nums1 不用进行扫尾操作 |
| [0089 题解](https://leetcode.cn/problems/gray-code/solution/lc89-fengwei2002-by-kycu-rjei/) | [89.格雷编码](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/89.格雷编码.cpp) | 找规律                  | 在将现有数字镜像对称之后，将上半部分尾部加上 0，将下半部分尾部加上 1 |
| [0090 题解](https://leetcode.cn/problems/subsets-ii/solution/lc90-fengwei2002-by-kycu-jkwn/) | [90.子集-ii](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/90.子集-ii.cpp) | DFS                     | 子集中可以包含包含重复元素，答案中不包含重复子集，排序之后`if (i > startIndex && nums[i] == nums[i - 1]), continue;` |
| [0091 题解](https://leetcode.cn/problems/decode-ways/solution/lc91-fengwei2002-by-kycu-1yv7/) | [91.解码方法](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/91.解码方法.cpp) | DP                      |                    带有条件的斐波那契数列                    |
| [0092 题解](https://leetcode.cn/problems/reverse-linked-list-ii/solution/lc92-fengwei2002-by-kycu-f9si/) | [92.反转链表-ii](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/92.反转链表-ii.cpp) | 链表                    |            翻转固定区间内的链表元素，一趟遍历完成            |
| [0093 题解](https://leetcode.cn/problems/restore-ip-addresses/solution/lc93-fengwei2002-by-kycu-ptu7/) | [93.复原-ip-地址](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/93.复原-ip-地址.cpp) | DFS                     |               刚好存在四位数字的时候放入结果中               |
| [0094 题解](https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/lc94-fengwei2002-by-kycu-9iye/) | [94.二叉树的中序遍历](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/94.二叉树的中序遍历.cpp) | 二叉树                  | 模板题，二叉树中序遍历迭代写法是先将左子树全部入栈，然后拐向右子树 |
| [0095 题解](https://leetcode.cn/problems/unique-binary-search-trees-ii/solution/lc95-fengwei2002-by-kycu-lrga/) | [95.不同的二叉搜索树-ii](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/95.不同的二叉搜索树-ii.cpp) | DFS                     | 根节点在 `1 - n` 中选取，左右根节点在lr区间选取，两两组合输出 |
| [0096 题解](https://leetcode.cn/problems/unique-binary-search-trees/solution/lc96-fengwei2002-by-kycu-lekx/) | [96.不同的二叉搜索树](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/96.不同的二叉搜索树.cpp) | DFS                     |             输出对应的卡特兰数，DP，或者暴力搜索             |
| [0097 题解](https://leetcode.cn/problems/interleaving-string/solution/lc97-fengwei2002-by-kycu-y68b/) | [97.交错字符串](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/97.交错字符串.cpp) | 字符串 DP               |        条件 DP `f[i][j] = f[i][j - 1] || f[i - 1][j]`        |
| [0098 题解](https://leetcode.cn/problems/validate-binary-search-tree/solution/lc98-fengwei2002-by-kycu-8dl4/) | [98.验证二叉搜索树](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/98.验证二叉搜索树.cpp) | 二叉树                  |                 判断中序遍历是否为 升序 数组                 |
| [0099 题解](https://leetcode.cn/problems/recover-binary-search-tree/solution/lc99-fengwei2002-by-kycu-45z2/) | [99.恢复二叉搜索树](https://github.com/fengwei2002/Algorithm/blob/main/Leetcode/99.恢复二叉搜索树.cpp) | 二叉树                  | 在一个数组中，寻找至多两个不满足升序的区间边界，进行边界值的交换 |