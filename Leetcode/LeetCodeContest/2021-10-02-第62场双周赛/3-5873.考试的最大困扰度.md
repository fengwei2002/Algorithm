
一位老师正在出一场由 n 道判断题构成的考试，每道题的答案为 true （用 'T' 表示）或者 false （用 'F' 表示）。老师想增加学生对自己做出答案的不确定性，方法是 最大化 有 连续相同 结果的题数。（也就是连续出现 true 或者连续出现 false）。

给你一个字符串 answerKey ，其中 answerKey[i] 是第 i 个问题的正确结果。除此以外，还给你一个整数 k ，表示你能进行以下操作的最多次数：

每次操作中，将问题的正确答案改为 'T' 或者 'F' （也就是将 answerKey[i] 改为 'T' 或者 'F' ）。
请你返回在不超过 k 次操作的情况下，最大 连续 'T' 或者 'F' 的数目。

输入：answerKey = "TTFF", k = 2
输出：4
解释：我们可以将两个 'F' 都变为 'T' ，得到 answerKey = "TTTT" 。
总共有四个连续的 'T' 。



对于数组 A 的区间，$[left,right]$ 只要他包含不超过 $k$ 个 $T$，我们就可以根据它构造出一段满足要求，并且长度为 $\textit{right} - \textit{left} + 1$ 的全是 $T$ 的区间。

因此，我们可以将该问题进行如下的转化，即：

> 对于任意的右端点 $\textit{right}$，希望找到最小的左端点 $\textit{left}$，使得 $[\textit{left}, \textit{right}]$ 包含不超过 k 个 T。  
只要我们枚举所有可能的右端点，将得到的区间的长度取最大值，即可得到答案。

``` cpp
class Solution {
  public:
    int maxConsecutiveAnswers(string s, int k) {
        int n = s.size();
        int FCount = 0, TCount = 0;
        int mx = 1;

        // 双指针
        for (int i = 0, j = 0; i < n; i++) {
            if (s[i] == 'F') FCount++;

            // 当计数超过 k 时, 需要收缩窗口
            while (j < i && FCount > k) {
                if (s[j] == 'F') FCount--;
                j++;
            }
            mx = max(mx, i - j + 1);
        }

        for (int i = 0, j = 0; i < n; i++) {
            if (s[i] == 'T') TCount++;
            while (j < i && TCount > k) {
                if (s[j] == 'T')
                    TCount--;
                j++;
            }
            mx = max(mx, i - j + 1);
        }
        return mx;
    }
};
```