- [题目链接](https://leetcode-cn.com/problems/A1NYOS/)  
- [题解链接](https://leetcode-cn.com/problems/A1NYOS/solution/jz2-11-fengwei2002-by-kycu-9l0a/)

https://github.com/fengwei2002/algorithm

给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的**最长连续子数组**，并返回该子数组的长度。

### 思路

将数组中的 0 视作 -1，则求连续相同 0 和 1 个数的子数组就是求连续和为 0 的子数组。

连续子数组的和可以用两个前缀和相减得到，故这里就是求下标差距最大的两个相等的前缀和。

使用哈希表记录前缀和及其下标。遍历时，若当前的前缀和在哈希表之前出现过，说明这个区间加减 1 的次数相同，则更新答案；否则将其值和下标加入哈希表。

注意哈希表中需要初始化一个前缀和 `hash[0] = -1` 保证初始值的计算正确。

### C++

``` cpp
class Solution {
public:
    int findMaxLength(vector<int>& nums) {
        int n = nums.size(); if (n == 0) return 0;
        unordered_map<int, int> hash;
        hash[0] = -1; // 如果第一个数字为 0 的话，0 - (-1) = 1 
        //只有前缀和不为0的才存入哈希表，哈希表第一个元素存放非零前缀和，第二个元素存放该前缀和的位置
        //（从数组头部到第i个元素的前缀和中，i就是该前缀和的位置）。

        int sum = 0;
        int maxLength = 0;
        for (int i = 0; i < n; i++) {
            sum += (nums[i] == 1 ? 1 : -1);
            if (hash.count(sum)) {          // 如果哈希表中可以找到当前的前缀和
                                            // 说明这个过程中加一的次数和减一的次数相等
                maxLength = max(maxLength, i - hash[sum]);
            } else {                        // 如果哈希表中找不到前缀和，将这个值用下标存储起来
                hash[sum] = i;
            }
        }
        return maxLength;
    }
};
```


``` cpp
class Solution {
public:
    int findMaxLength(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) return 0;

        unordered_map<int, int> hash;
        hash[0] = -1;

        int sum = 0;
        int maxLength = 0;

        for (int i = 0; i < n; i++) {
            sum += (nums[i] == 1 ? 1 : -1);
            if (hash.count(sum)) {
                maxLength = max(maxLength, i - hash[sum]);
            } else {
                hash[sum] = i;
            }
        }

        return maxLength;
    }
};
```

### GO


``` go
func findMaxLength(nums []int) int {
    n := len(nums)
    if n == 0 {
        return 0
    }

    hash := make(map[int]int)
    hash[0] = -1

    sum := 0
    maxLength := 0

    for i := 0; i < n; i++ {
        if nums[i] == 1 {
            sum += 1
        } else {
            sum += -1
        }

        if _, ok := hash[sum]; ok == true {
            maxLength = max(maxLength, i - hash[sum])
        } else {
            hash[sum] = i
        }
    }

    return maxLength
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```