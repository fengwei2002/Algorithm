- [题目链接](https://leetcode-cn.com/problems/aseY1I/)  
- [题解链接](https://leetcode-cn.com/problems/aseY1I/solution/jz2-05-fengwei2002-by-kycu-1jti/)

https://github.com/fengwei2002/algorithm

### 思路

由于 每个字符串中 出现的 字符种类 数量，最多只有 26 个

所以，每个字符串都可以用一个 数字来代表这个 字符串中，是否 出现过 26 个小写英文字母

遍历一遍字符串数组，预处理状态数组到 state 中

然后对于所有字符串进行两两匹配，如果对应的 `state[i] & state[j] == 0`, 说明这两个数字的二进制表示，没有一位是相同的 1， 也就是代表这两个数字对应的两个字符串中没有出现过相同的小写字母

计算求最大值即可

### C++

``` cpp
class Solution {
public:
    int maxProduct(vector<string>& words) {
        vector<int> state;
        for (auto word : words) {
            int s = 0; 
            for (auto c : word) {
                // 某个字符减去 a 就是他是 a - z 的第几个数字
                // 因为判断的是每个字符串中存在那些 字符
                // 所以 就将 2 ^ (c - 'a') 和 s 进行 或操作，
                // 最后 s 存储的值就代表了 这个 word 中存在 那些字符，
                // 存在这个字符，那么二进制表示 s 之后，对应的下标位置就是 1
                s = s | 1 << (c - 'a');
            }
            state.push_back(s);
        }

        int ans = 0;
        for (int i = 0; i < words.size(); i++) {
            for (int j = i + 1; j < words.size(); j++) {
                if ((state[i] & state[j]) == 0) {
                    int t = words[i].size() * words[j].size();
                    ans = max(ans, t);
                }
            }
        }

        return ans;
    }
};
```

### GO

``` go
func maxProduct(words []string) int {
    flag := []int{}
    for _, word := range words {
        s := 0
        for _, c := range word {
            s |= (1 << (c - 'a'))
        }
        flag = append(flag, s)
    }

    ans := 0

    for i := 0; i < len(words); i++ {
        for j := 0; j < len(words); j++ {
            if (flag[i] & flag[j]) == 0 {
                t := len(words[i]) * len(words[j])
                ans = max(ans, t) 
            }
        }
    }

    return ans
}


func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```